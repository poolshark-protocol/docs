{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"docs/","text":"COMING SOON \u00b6","title":"Documentation"},{"location":"docs/#coming-soon","text":"","title":"COMING SOON"},{"location":"intro/conclusion/","text":"Conclusion \u00b6","title":"Conclusion"},{"location":"intro/conclusion/#conclusion","text":"","title":"Conclusion"},{"location":"intro/","text":"Introduction \u00b6 Core Concepts \u00b6 At the most basic level, the main focus of the DCEX protocol is to group common DeFi executions into bulk tasks, while being cost and time efficient. While this is not a new solution to an old problem, it does utilize a different core design than that in current production or being talked about in main-stream crypto news. Let\u2019s talk about a few solutions that we have seen or that have been proposed as an alternative then finally the new solution (DCEX) Solution A \u00b6 By utilizing a sub-chain such as arweave as a storage layer since gas costs are much cheaper in sub-chains compared to ETH mainnet, these solutions work by using decentralized services and chains to store the data, but the scalability can be questioned since they are still relying on cost of gas of the sub-chain to not succeed the price people are willing to pay. The sub-chains try to offset this problem by modeling new and interesting gas models (Needs more research). Solution B \u00b6 It may sacrifice decentralization to negate the gas of a sub-chain by utilizing events mixed with off-chain bots to relay back on-chain when conditions are met. The most obvious example of this is a centralized exchange like Binance or Coinbase, you interact with their service through an API, all balances are stored in shared wallets where the keys are unknown to the end user, and each individual user\u2019s balance is known through tracking token deposits and spends which are then stored in some database. But all execution that needs to happen, will be executed on the relevant chain. Solution DCEX \u00b6 By combining the previous solutions ideas into a new model, we are able to have the ambiguity of full decentralization, execution being requested then executed on the relevant chain, and minimal costs (compared to current on-chain solutions). Since the solution is a combination of the above, it also shares some of the pros and cons of the above, to use the protocol you have to deposit into the contract, similar to Solution B . It utilizes a decentralized indexing service, The Graph, whereas Solution A utilizes sub-chains, but these are used in quite similar ways. The base actions required to interact with a DCEX protocol are as follows: Optional: Deposit ERC-20 token into the DCEX-ERC20-Core contract via deposit(address depositToken, uint256 depositAmount) When depositing ETH, utilize msg.value along with any other token you wish to deposit. Make an action request, either through a Module or through the Core For example, you want to Transfer DAI to your friend, you can call the core\u2019s transfer(address transferToken, uint256 transferAmount, address receiver) function, if the receiver doesn't have an account it will create one for them, thus allowing the receiver to \u2018 redeem \u2019 their token simply by using the DCEX protocol, or withdrawing to an external address [Diagram of DCEX hierarchy]","title":"Overview"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#core-concepts","text":"At the most basic level, the main focus of the DCEX protocol is to group common DeFi executions into bulk tasks, while being cost and time efficient. While this is not a new solution to an old problem, it does utilize a different core design than that in current production or being talked about in main-stream crypto news. Let\u2019s talk about a few solutions that we have seen or that have been proposed as an alternative then finally the new solution (DCEX)","title":"Core Concepts"},{"location":"intro/#solution-a","text":"By utilizing a sub-chain such as arweave as a storage layer since gas costs are much cheaper in sub-chains compared to ETH mainnet, these solutions work by using decentralized services and chains to store the data, but the scalability can be questioned since they are still relying on cost of gas of the sub-chain to not succeed the price people are willing to pay. The sub-chains try to offset this problem by modeling new and interesting gas models (Needs more research).","title":"Solution A"},{"location":"intro/#solution-b","text":"It may sacrifice decentralization to negate the gas of a sub-chain by utilizing events mixed with off-chain bots to relay back on-chain when conditions are met. The most obvious example of this is a centralized exchange like Binance or Coinbase, you interact with their service through an API, all balances are stored in shared wallets where the keys are unknown to the end user, and each individual user\u2019s balance is known through tracking token deposits and spends which are then stored in some database. But all execution that needs to happen, will be executed on the relevant chain.","title":"Solution B"},{"location":"intro/#solution-dcex","text":"By combining the previous solutions ideas into a new model, we are able to have the ambiguity of full decentralization, execution being requested then executed on the relevant chain, and minimal costs (compared to current on-chain solutions). Since the solution is a combination of the above, it also shares some of the pros and cons of the above, to use the protocol you have to deposit into the contract, similar to Solution B . It utilizes a decentralized indexing service, The Graph, whereas Solution A utilizes sub-chains, but these are used in quite similar ways. The base actions required to interact with a DCEX protocol are as follows: Optional: Deposit ERC-20 token into the DCEX-ERC20-Core contract via deposit(address depositToken, uint256 depositAmount) When depositing ETH, utilize msg.value along with any other token you wish to deposit. Make an action request, either through a Module or through the Core For example, you want to Transfer DAI to your friend, you can call the core\u2019s transfer(address transferToken, uint256 transferAmount, address receiver) function, if the receiver doesn't have an account it will create one for them, thus allowing the receiver to \u2018 redeem \u2019 their token simply by using the DCEX protocol, or withdrawing to an external address [Diagram of DCEX hierarchy]","title":"Solution DCEX"},{"location":"intro/security/","text":"Security \u00b6","title":"Security"},{"location":"intro/security/#security","text":"","title":"Security"},{"location":"intro/layers/code-storage/","text":"Trustless Code Storage \u00b6 What It Does \u00b6 The code storage layer directly relates to the execution layer . The code that the execution layer uses exists on IPFS, which is immutable, the IPFS hash resolves to a precompiled AssemblyScript file, compiled into Wasm binary instructions which can then be executed on. [DIAGRAM HERE: SHOWING RETRIEVAL OF POLYWRAP RESOLVER FROM IPFS]","title":"Code Storage"},{"location":"intro/layers/code-storage/#trustless-code-storage","text":"","title":"Trustless Code Storage"},{"location":"intro/layers/code-storage/#what-it-does","text":"The code storage layer directly relates to the execution layer . The code that the execution layer uses exists on IPFS, which is immutable, the IPFS hash resolves to a precompiled AssemblyScript file, compiled into Wasm binary instructions which can then be executed on. [DIAGRAM HERE: SHOWING RETRIEVAL OF POLYWRAP RESOLVER FROM IPFS]","title":"What It Does"},{"location":"intro/layers/execution/","text":"Execution \u00b6 What It Does \u00b6 Execution on-chain is required to reflect any requests users make on-chain. In the case of the GroupSwap feature, multiple users come together to fill a gas tank for a single swap on-chain. Example graph LR A[Gelato Bot] -->|Pull Code from IPFS| B[IPFS] B -->|Call to Query Layer| C{{Query Layer}}; C -->|Execution Needed?| D[Call On Chain Function]; C -->|No Execution Needed?| E[return]; The actions taken on-chain utilize data from The Graph Network. This data connection is made possible by Polywrap resolvers that run on Gelato Network nodes and query data from The Graph. Polywrap resolvers have a basic true/false 'checker' function that is run to determine if anything needs to be done on-chain. For example, if a gas tank is full for a given swap pair, a swap will be executed on-chain and the output token will be distributed evenly amongst the participants based on the amount of input token they contributed to the pool. Example graph TD A[Gelato Bot] -->|Pull Code from IPFS| B[IPFS] B -->|Call to Query Layer| C{{Query Layer}}; C -->|Gas Tank Full?| D[Call On Chain Function]; C -->|Gas Tank Not Full?| E[return]; D -->|Swap Happens| F[Emit event that states swap happened]; [DIAGRAM HERE: SHOWING DISTRIBUTION OF OUTPUT TOKEN IN THE GRAPH] The PoolSharks Team has built a DEX aggregator that will handle the liquidity sourcing in the case of the GroupSwap feature. As more features are integrated with the PoolSharks Protocol, more contracts will be required for the purposes of routing common requests on-chain and finding the most cost-effective path. Abstraction \u00b6 The Execution Layer abstracts away users having to set their own gas price. Currently this gas price is set by Gelato. The PoolSharks Team is exploring leveraging of data to set other parameters such as slippage on behalf of users. User Functionality \u00b6 The Gelato Network will enable asset transfer to be automated either on behalf of a user or a set of user requests. Withdraws will be processed in this manner where a withdraw request is submitted and then finalized on-chain once processed by a Gelato Polywrap bot. Trustless data is a key factor here to ensure the data being served matches what users submitted on-chain. Routing requests to other on-chain protocols is also handled by Gelato Polywrap bots, such as in the case of a Uniswap swap or an Aave deposit call. Events are then emitted from the resulting on-chain action and then reflected back in the Core ERC20 Subgraph for syncing purposes. Production Requirements \u00b6 Currently, anyone can create a task for a smart contract function that is executable by the Gelato Network. However, in our case we need to limit execution of our Core ERC20 contract functions to whitelisted modules only. Certainly we don't 'Bob down the street' executing our smart contract functions and passing bad data. Additionally, the protocol will ideally deploy immutable Gelato tasks in an effort to make the system behave more like a smart contract. Censorship resistance, immutability, and non-custodial are all descriptors we intend to reflect in the design of this protocol.","title":"On Chain Execution"},{"location":"intro/layers/execution/#execution","text":"","title":"Execution"},{"location":"intro/layers/execution/#what-it-does","text":"Execution on-chain is required to reflect any requests users make on-chain. In the case of the GroupSwap feature, multiple users come together to fill a gas tank for a single swap on-chain. Example graph LR A[Gelato Bot] -->|Pull Code from IPFS| B[IPFS] B -->|Call to Query Layer| C{{Query Layer}}; C -->|Execution Needed?| D[Call On Chain Function]; C -->|No Execution Needed?| E[return]; The actions taken on-chain utilize data from The Graph Network. This data connection is made possible by Polywrap resolvers that run on Gelato Network nodes and query data from The Graph. Polywrap resolvers have a basic true/false 'checker' function that is run to determine if anything needs to be done on-chain. For example, if a gas tank is full for a given swap pair, a swap will be executed on-chain and the output token will be distributed evenly amongst the participants based on the amount of input token they contributed to the pool. Example graph TD A[Gelato Bot] -->|Pull Code from IPFS| B[IPFS] B -->|Call to Query Layer| C{{Query Layer}}; C -->|Gas Tank Full?| D[Call On Chain Function]; C -->|Gas Tank Not Full?| E[return]; D -->|Swap Happens| F[Emit event that states swap happened]; [DIAGRAM HERE: SHOWING DISTRIBUTION OF OUTPUT TOKEN IN THE GRAPH] The PoolSharks Team has built a DEX aggregator that will handle the liquidity sourcing in the case of the GroupSwap feature. As more features are integrated with the PoolSharks Protocol, more contracts will be required for the purposes of routing common requests on-chain and finding the most cost-effective path.","title":"What It Does"},{"location":"intro/layers/execution/#abstraction","text":"The Execution Layer abstracts away users having to set their own gas price. Currently this gas price is set by Gelato. The PoolSharks Team is exploring leveraging of data to set other parameters such as slippage on behalf of users.","title":"Abstraction"},{"location":"intro/layers/execution/#user-functionality","text":"The Gelato Network will enable asset transfer to be automated either on behalf of a user or a set of user requests. Withdraws will be processed in this manner where a withdraw request is submitted and then finalized on-chain once processed by a Gelato Polywrap bot. Trustless data is a key factor here to ensure the data being served matches what users submitted on-chain. Routing requests to other on-chain protocols is also handled by Gelato Polywrap bots, such as in the case of a Uniswap swap or an Aave deposit call. Events are then emitted from the resulting on-chain action and then reflected back in the Core ERC20 Subgraph for syncing purposes.","title":"User Functionality"},{"location":"intro/layers/execution/#production-requirements","text":"Currently, anyone can create a task for a smart contract function that is executable by the Gelato Network. However, in our case we need to limit execution of our Core ERC20 contract functions to whitelisted modules only. Certainly we don't 'Bob down the street' executing our smart contract functions and passing bad data. Additionally, the protocol will ideally deploy immutable Gelato tasks in an effort to make the system behave more like a smart contract. Censorship resistance, immutability, and non-custodial are all descriptors we intend to reflect in the design of this protocol.","title":"Production Requirements"},{"location":"intro/layers/","text":"Layers \u00b6 The DCEX design consists of 5 seperate layers, all intended to work together in an attempt to provide a fully decentralized execution loop, reduce user consumed gas, and present new ways to perform complex and costly tasks by utilizing code execution off-chain Layers Layer Short Description User Interaction info Data Ingestion info Data Queries info On Chain Execution info Code Stoarge info","title":"Layers"},{"location":"intro/layers/#layers","text":"The DCEX design consists of 5 seperate layers, all intended to work together in an attempt to provide a fully decentralized execution loop, reduce user consumed gas, and present new ways to perform complex and costly tasks by utilizing code execution off-chain Layers Layer Short Description User Interaction info Data Ingestion info Data Queries info On Chain Execution info Code Stoarge info","title":"Layers"},{"location":"intro/layers/ingestion/","text":"Data Ingestion \u00b6 What It Does \u00b6 Once events occur on-chain, the Core ERC20 Subgraph receives record of what happened and reflects those changes via event handlers. For example, in the case of a Deposit event, the following event is emitted: Deposit (address user, address token, uint256 amount) The Deposit handler will assign the balance amount to the account user for the contract address token . Example graph LR A[Deposit Event] --> B{{Deposit Handler}}; B -->|Validates Data| C[(<br/>+User Balance)]; The balance is now spendable by the user, meaning they can request a withdraw, groupswap, etc. Once spendable balance has been associated with a user request, the balance will be made nonspendable in the amount requested by the user. This prevents the classical double-spending problem from occurring. Example graph LR A[GroupSwap Event] --> B{{GroupSwap Handler}}; B -->|Validates Data| C[(<br/>-unreservedBalance<br/>+reservedBalance)]; In our system design, we typically refer to this process as making a reservation . Balance is nonspendable until the order is cancelled by the user or the order is fulfilled. Abstraction \u00b6 Here the Core ERC20 Subgraph is abstracting away the costs of storing all the accounting and user request information on-chain and instead opting for the data to be availalble via The Graph Network. Production Requirements \u00b6 Indexing speed here is a potential issue, however Ethereum is limited to 15 TPS which bottlenecks the amount of events the DCEX Subgraphs will be processing. One solution here is to have the team run its own node within The Graph Network, which will to a large guarantee real-time availability of Subgraph data. The other potential pitfall is indexing correctness, for which a process needs to be developed around creating disputes for Proof of Indexing (POI) when data is indexed in an invalid manner.","title":"Data Ingestion"},{"location":"intro/layers/ingestion/#data-ingestion","text":"","title":"Data Ingestion"},{"location":"intro/layers/ingestion/#what-it-does","text":"Once events occur on-chain, the Core ERC20 Subgraph receives record of what happened and reflects those changes via event handlers. For example, in the case of a Deposit event, the following event is emitted: Deposit (address user, address token, uint256 amount) The Deposit handler will assign the balance amount to the account user for the contract address token . Example graph LR A[Deposit Event] --> B{{Deposit Handler}}; B -->|Validates Data| C[(<br/>+User Balance)]; The balance is now spendable by the user, meaning they can request a withdraw, groupswap, etc. Once spendable balance has been associated with a user request, the balance will be made nonspendable in the amount requested by the user. This prevents the classical double-spending problem from occurring. Example graph LR A[GroupSwap Event] --> B{{GroupSwap Handler}}; B -->|Validates Data| C[(<br/>-unreservedBalance<br/>+reservedBalance)]; In our system design, we typically refer to this process as making a reservation . Balance is nonspendable until the order is cancelled by the user or the order is fulfilled.","title":"What It Does"},{"location":"intro/layers/ingestion/#abstraction","text":"Here the Core ERC20 Subgraph is abstracting away the costs of storing all the accounting and user request information on-chain and instead opting for the data to be availalble via The Graph Network.","title":"Abstraction"},{"location":"intro/layers/ingestion/#production-requirements","text":"Indexing speed here is a potential issue, however Ethereum is limited to 15 TPS which bottlenecks the amount of events the DCEX Subgraphs will be processing. One solution here is to have the team run its own node within The Graph Network, which will to a large guarantee real-time availability of Subgraph data. The other potential pitfall is indexing correctness, for which a process needs to be developed around creating disputes for Proof of Indexing (POI) when data is indexed in an invalid manner.","title":"Production Requirements"},{"location":"intro/layers/query/","text":"Database Query \u00b6 What It Does \u00b6 The query layer resolves the trustless interactions between the Execution Layer (Gelato Network) and the Data Layer (The Graph Network) and ensures data has been properly validated prior to initiating any transactions on-chain. This layer is still under heavy construction and is the primary blocker for creating a fully trustless execution loop comprised of on-chain and off-chain components. Example graph LR A[User] -->|API Call| B{{Query Layer}}; B -->|Query Subgraph| C[Decentralized Node Query]; C -->|valid zkSnark?| D[return response]; C -->|invalid zkSnark?| E[Submit Dispute]; E -->|Retry| B; Abstraction \u00b6 The Query Layer abstracts away receiving trustless data from The Graph decentralized network back on-chain in the form of withdraws, swaps, and other on-chain settlement which are executed on the Gelato Network. User Functionality \u00b6 Users looking to engage in the following areas can utilize the Query Layer to receive trustless data: MEV, predictions, analytics, monitoring, etc. These are just a few examples of users that might have a financial or data-driven incentive to query The Graph Network. We believe bringing a financial use case to data networks will help them flourish in the long-run. If you believe you have a decentralized network where we can host our API for validating data from The Graph, please reach out to us via Twitter or Discord. Production Requirements \u00b6 Trustless data is an absolute requirement in creating a non-custodial trustless exchange where users can coordinate on-chain actions together. Likely we will have to build out our own data validation layer in an effort to dispute either data that is indexed incorrectly or query results that are found to be invalid. This will effectively slash bad actors on The Graph Network and prevent our Execution Layer from acting on invalid data.","title":"Data Queries"},{"location":"intro/layers/query/#database-query","text":"","title":"Database Query"},{"location":"intro/layers/query/#what-it-does","text":"The query layer resolves the trustless interactions between the Execution Layer (Gelato Network) and the Data Layer (The Graph Network) and ensures data has been properly validated prior to initiating any transactions on-chain. This layer is still under heavy construction and is the primary blocker for creating a fully trustless execution loop comprised of on-chain and off-chain components. Example graph LR A[User] -->|API Call| B{{Query Layer}}; B -->|Query Subgraph| C[Decentralized Node Query]; C -->|valid zkSnark?| D[return response]; C -->|invalid zkSnark?| E[Submit Dispute]; E -->|Retry| B;","title":"What It Does"},{"location":"intro/layers/query/#abstraction","text":"The Query Layer abstracts away receiving trustless data from The Graph decentralized network back on-chain in the form of withdraws, swaps, and other on-chain settlement which are executed on the Gelato Network.","title":"Abstraction"},{"location":"intro/layers/query/#user-functionality","text":"Users looking to engage in the following areas can utilize the Query Layer to receive trustless data: MEV, predictions, analytics, monitoring, etc. These are just a few examples of users that might have a financial or data-driven incentive to query The Graph Network. We believe bringing a financial use case to data networks will help them flourish in the long-run. If you believe you have a decentralized network where we can host our API for validating data from The Graph, please reach out to us via Twitter or Discord.","title":"User Functionality"},{"location":"intro/layers/query/#production-requirements","text":"Trustless data is an absolute requirement in creating a non-custodial trustless exchange where users can coordinate on-chain actions together. Likely we will have to build out our own data validation layer in an effort to dispute either data that is indexed incorrectly or query results that are found to be invalid. This will effectively slash bad actors on The Graph Network and prevent our Execution Layer from acting on invalid data.","title":"Production Requirements"},{"location":"intro/layers/user-interaction/","text":"User Interaction \u00b6 What It Does \u00b6 This is the layer which users will interact with directly to request performing any action on assets held in DCEX contracts. It contains a set of Smart Contracts that, at their most basic level, provide a way for a user to emit a given event. In more advanced cases, it can be considered a hybrid contract, where an external user can interact with the liquidity inside DCEX directly without having to perform a deposit or withdraw. Ultimately, an event will still be emitted such that any changes can take effect in the Core ERC20 Subgraph. function transfer ( address transferToken , uint256 transferAmount , address receiver ) external override { address sender = msg.sender ; emit TransferRequest ( sender , transferToken , transferAmount , receiver ); } Abstraction \u00b6 Since funds are being stored in a common contract between users, and funds can be spent by modules, certain EIP standard functions such as Transfer are abstracted away from during internal transactions (i.e. within the Subgraph). Let's take for example an ERC20 transfer to your friend: Example Standard DCEX graph LR A[User] -->|Contract call| B{ERC20.transfer}; B -->|Update Contract Storage| C(( -sender Balance<br/>+receiver Balance)); C --> D[return true]; graph LR A[User] -->|Contract call| B{Core.transfer}; B -->|Emits Event| C{{Subgraph Ingestion}}; C -->|Updates Subgraph Data| D[(<br/>-sender Balance<br/>+receiver Balance)]; Normally a user with a wallet would call to the ERC20 transfer(address dest, uint256 amount) method and use up about 30,000-60,000 gas units. In the case DCEX, if a user wants to transfer ERC20 token internally, they would call to the DCEX ERC20 Core contract's transfer(address token, uint256 amount, address receiver) method, consuming approximately 24,000-26,000 gas units. Since funds are local, there is no need to execute any code on-chain other than the event stating the action. The Ingestion Layer will handle rassigning balances as needed. Taking this to the protocol level, we can imagine a DCEX user interacting with a Module like GroupSwap, which allows users to pool gas together for on-chain swaps. Instead of a user calling to the ERC20 contract's approve() method and the DEX contract's swap method, they can call to the relevant Module contract's groupSwap() function. Example Standard DCEX GroupSwap Module graph TD A[User] -->|Contract call| B{DEX.swap}; B -->|Transfer Token In| C[DEX Processes Swap]; C -->|Transfer Token Out| D[return true]; graph TD A[User] -->|Contract call| B{GroupSwap.swap}; B -->|Emits Event| C{{Subgraph Ingestion}}; B --> G[Reserve Token]; C -->|Updates Subgraph Data| D[(<br/>Open Order<br/>Update Group)]; E[Group Executes] --> F[Token is reallocated to user]; Each request for the GroupSwap module consumes approximately 25,000-27,000 gas units. The amount of gas units consumed by a request to a Module can and will vary based on the amount of data emitted. The DCEX user doesn't need to perform an approve() , because the groupSwap() function calls to the Core contract's reserveToken() function. In this design, reservations can be seen as approvals, where a reservation is defined by a user calling to a module which then calls to the Core ERC20 contract to reserve or unreserve the token. User Functionality \u00b6 Any actions a user will perform is through a contract call to the Core or any authorized Module. For info on active Modules and what each function does in detail, see the developer docs. [LINK TO MODULE/DEVELOPER DOCS] Production Requirements \u00b6 AUDITS REQUIRED This layer should be production ready; there are not any major differences between these contracts and any other protocol's contracts'.","title":"User Interaction"},{"location":"intro/layers/user-interaction/#user-interaction","text":"","title":"User Interaction"},{"location":"intro/layers/user-interaction/#what-it-does","text":"This is the layer which users will interact with directly to request performing any action on assets held in DCEX contracts. It contains a set of Smart Contracts that, at their most basic level, provide a way for a user to emit a given event. In more advanced cases, it can be considered a hybrid contract, where an external user can interact with the liquidity inside DCEX directly without having to perform a deposit or withdraw. Ultimately, an event will still be emitted such that any changes can take effect in the Core ERC20 Subgraph. function transfer ( address transferToken , uint256 transferAmount , address receiver ) external override { address sender = msg.sender ; emit TransferRequest ( sender , transferToken , transferAmount , receiver ); }","title":"What It Does"},{"location":"intro/layers/user-interaction/#abstraction","text":"Since funds are being stored in a common contract between users, and funds can be spent by modules, certain EIP standard functions such as Transfer are abstracted away from during internal transactions (i.e. within the Subgraph). Let's take for example an ERC20 transfer to your friend: Example Standard DCEX graph LR A[User] -->|Contract call| B{ERC20.transfer}; B -->|Update Contract Storage| C(( -sender Balance<br/>+receiver Balance)); C --> D[return true]; graph LR A[User] -->|Contract call| B{Core.transfer}; B -->|Emits Event| C{{Subgraph Ingestion}}; C -->|Updates Subgraph Data| D[(<br/>-sender Balance<br/>+receiver Balance)]; Normally a user with a wallet would call to the ERC20 transfer(address dest, uint256 amount) method and use up about 30,000-60,000 gas units. In the case DCEX, if a user wants to transfer ERC20 token internally, they would call to the DCEX ERC20 Core contract's transfer(address token, uint256 amount, address receiver) method, consuming approximately 24,000-26,000 gas units. Since funds are local, there is no need to execute any code on-chain other than the event stating the action. The Ingestion Layer will handle rassigning balances as needed. Taking this to the protocol level, we can imagine a DCEX user interacting with a Module like GroupSwap, which allows users to pool gas together for on-chain swaps. Instead of a user calling to the ERC20 contract's approve() method and the DEX contract's swap method, they can call to the relevant Module contract's groupSwap() function. Example Standard DCEX GroupSwap Module graph TD A[User] -->|Contract call| B{DEX.swap}; B -->|Transfer Token In| C[DEX Processes Swap]; C -->|Transfer Token Out| D[return true]; graph TD A[User] -->|Contract call| B{GroupSwap.swap}; B -->|Emits Event| C{{Subgraph Ingestion}}; B --> G[Reserve Token]; C -->|Updates Subgraph Data| D[(<br/>Open Order<br/>Update Group)]; E[Group Executes] --> F[Token is reallocated to user]; Each request for the GroupSwap module consumes approximately 25,000-27,000 gas units. The amount of gas units consumed by a request to a Module can and will vary based on the amount of data emitted. The DCEX user doesn't need to perform an approve() , because the groupSwap() function calls to the Core contract's reserveToken() function. In this design, reservations can be seen as approvals, where a reservation is defined by a user calling to a module which then calls to the Core ERC20 contract to reserve or unreserve the token.","title":"Abstraction"},{"location":"intro/layers/user-interaction/#user-functionality","text":"Any actions a user will perform is through a contract call to the Core or any authorized Module. For info on active Modules and what each function does in detail, see the developer docs. [LINK TO MODULE/DEVELOPER DOCS]","title":"User Functionality"},{"location":"intro/layers/user-interaction/#production-requirements","text":"AUDITS REQUIRED This layer should be production ready; there are not any major differences between these contracts and any other protocol's contracts'.","title":"Production Requirements"}]}