{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"overview/cover-pools/","title":"Cover Pools","text":"<p>Cover Pools allow you to create positions to increase exposure to a specific token conditional on it increasing in price on a given pair.</p> <ul> <li>If the ETH price increases, the pool sells DAI and increases the amount of ETH exposure</li> <li>If the ETH price decreases, the pool sells ETH and increases the amount of DAI exposure</li> </ul> <p>If a position is or has been in range on a bidirectional automated market maker it increases the exposure to the token dropping in price or has all exposure to the token dropping in price.</p> <ul> <li>If the market wants ETH, the pool takes DAI and increases the ETH to DAI price</li> <li>If the market wants DAI, the pool takes ETH and decreases the ETH to DAI price.   This allows them to function as a hedging tool if the user wants to enter or exit an ERC-20 token over some range. </li> </ul> <p>If this was attempted using a position with a fixed price such as a limit order (as done when providing liquidity) the position will either underprice the assets or it won't be filled.</p> <p>Cover pools allow you to create a position to provide liquidity at a set price and when the TWAP price nears the liquidity becomes available to trade. The liquidity is then a part of a dutch auction.</p> <p>Cover Pools operate with a Gradual Dutch Auction (GDA) meaning that you can start at the price indicated by the current price tick of your position and begin to offer a more discounted price until it is accepted by the market.</p> <p>As a Range Order, Cover Positions will periodically unlock liquidity across a price range as the Time-Weighted Average Price (TWAP) increases or decreases (indicated by the user).</p> <p>This is because we don't want the pool to unlock liquidity due to high frequency market volatility which will be closed out in an extremely short time period due to arbitrage.</p>"},{"location":"overview/cover-pools/#applications-non-exhaustive","title":"Applications (non-exhaustive)","text":""},{"location":"overview/cover-pools/#covering-potential-impermanent-loss","title":"Covering Potential Impermanent Loss","text":"<p>If you are seeking to cover impermanent loss dynamically as the price moves, it is ideal for your lower and upper bound to match your current position on either Uniswap v3 or Poolshark. It is okay to put the same upper and lower bound as on your original Range Position NFT. The <code>PoolsharkCoverPair</code> contract will automatically calculate how much input token you should transfer into the pool based on the currently valid price range.</p> <p>If the user wants to increase capital efficiency, they can either increase the lower bound or decrease the upper bound so that less upfront capital is required.</p> <p>Rather, Cover positions are meant to decrease exposure of one asset and increase exposure to another as the price of the initial asset becomes worse. This is a way for LPs to hedge a portion of their portfolio in the case the market price moves against a given asset.  </p> <p>Assuming the user wants to cover any potential impermanent loss, this range should match their original LP position and the value of the position should also be equal to more accurately cover impermanent loss.</p>"},{"location":"overview/cover-pools/#trading-conditional-on-price-changes","title":"Trading Conditional on Price Changes","text":"<p>For users seeking to trade into an asset starting at some price (example in the image below), they can set the lower bound as the point where they want to start transitioning from the input token to the output token. </p> <p>The Cover Pool will unlock liquidity at each price point based on the total amount of liquidity available in the pool for a given pair direction.</p> <p>Capital efficiency can be improved by selecting a smaller range over which to trade to the desired output token.</p> <p>Cover LP Positions can also be used to deleverage long or short positions prior to getting liquidated.</p>"},{"location":"overview/cover-pools/#how-auctions-work","title":"How Auctions Work","text":"<p>In order to be competitive with the current market rate, the pool must have a dynamic pricing mechanism so the position is filled as soon as possible while keeping any discount at a minimum. For this, Cover Pools use Gradual Dutch Auctions to raise or lower the pool price (depending on buying or selling a token) to satisfy market demand for an asset within a trading pair at that point in time.</p> <p>From Paradigm's Gradual Dutch Auction article: <pre><code>Here, the price for every auction decays exponentially according to some `decay constant`.\nThe starting price of each auction increases by some fixed `scale factor`.\nAnd the starting price of the first auction is given by some `initial price`.\n</code></pre></p> <p>Combining these values gives us an exponentially changing market price for each tick of liquidity we auction off. The price will never deviate by more than one price tick (e.g. 0.1% for the ETH-USDC 0.05% tier).</p>"},{"location":"overview/cover-pools/#how-volatility-tiers-work","title":"How Volatility Tiers work","text":"<p>Volatility tiers set a few different parameters when a pool is created: the auction length, syncing fee, minimum position size, minimum position width. </p> <p>Auction length is the amount of blocks until the next auction can be triggered by a price change. </p> <p>A syncing fee is for when an auction goes unfilled and it needs to be moved to the next price tick in which liquidity is added to the auction at the new price tick. </p> <p>Minimum position size is the minimum amount of liquidity required at a price tick to commence an auction. </p> <p>Minimum position width is the minimum amount of price ticks a position can span.</p> <p></p>"},{"location":"overview/glossary/","title":"Glossary","text":""},{"location":"overview/glossary/#automated-market-maker","title":"Automated Market Maker","text":"<p>Automated Market Makers (AMM) are a type of Decentralized Exchange (DEX) that employs a fixed algorithm for providing liquidity. They typically use a liquidity pool to store liquidity from all liquidity providers (LPs) associated with that pool.</p> <p>See more here.</p> <p>See [Bidirectional]</p>"},{"location":"overview/glossary/#bidirectional-automated-market-maker","title":"Bidirectional Automated Market Maker","text":"<p>Liquidity pools which facilitate both buying and selling on a token pair.</p> <p>Example: Uniswap, Curve Finance</p>"},{"location":"overview/glossary/#directional-automated-market-maker","title":"Directional Automated Market Maker","text":"<p>Liquidity pools which facilitate only buying or only selling on a token pair.</p> <p>Example: Poolshark</p>"},{"location":"overview/glossary/#decentralized-exchange","title":"Decentralized Exchange","text":"<p>Decentralized Exchanges (DEXes) are a peer-to-peer marketplace where users can trade assets in a non-custodial manner without the need for an intermediary overseeing the custody and transfer of assets.</p>"},{"location":"overview/glossary/#dutch-auction","title":"Dutch Auction","text":"<p>A Dutch auction operates in the reverse fashion in comparison to what many have come to know as an English auction. Dutch auctions are started at a high price and then over time the items are discounted by the auctioneer until all assets are sold. Dutch auctions have come to be used often in decentralized finance by lending protocols liquidating collateral by auctioning it off. One such example of this is MakerDAO using this for liquidating collateral.</p> <p>The benefit of Dutch auctions is that they allow for partial sales throughout the auction. For blockchain use cases, these are superior to English auctions where the bids and asks have to constantly be adjusted via transactions. They also disclose minimal amounts of information as bids are instantly matched and thus there is less information on who you're bidding against. This means that it is not possible for a bidder to purposely outbid another, a bidder must know what their acceptable price is before the auction starts, this maximizes the amount returned in auctions as it is first come first serve.</p> <p>Dutch auctions are also used by Opium Protocol and were featured by Paradigm in a series of writings focusing on Gradual Dutch Auctions.</p>"},{"location":"overview/glossary/#fee-tier","title":"Fee Tier","text":"<p>A fee tier is the percentage fee that a taker must pay when swapping with a pool. Fee tiers determine the tick spacing as the fee tier is half the size of each price tick. For more information please check Price Ticks.</p>"},{"location":"overview/glossary/#full-range","title":"Full-Range","text":"<p>A Full-Range is a descriptive term for when users provide liquidity to an AMM spanning the entire possible range.</p> <p>Example: Uniswap v2 LP positions</p>"},{"location":"overview/glossary/#limit-order-book","title":"Limit Order Book","text":"<p>A limit order book is a record of outstanding limit orders maintained by an exchange. A limit order is a type of order to buy or sell an asset at a specific price or better. When a limit order for an asset is entered, it is kept on record by the limit order book. In order to take from the limit order book users must create a market order.</p>"},{"location":"overview/glossary/#liquidity-pool","title":"Liquidity Pool","text":"<p>A smart contract containing a collection of digital assets accumulated to enable trading and/or yield opportunities.</p>"},{"location":"overview/glossary/#liquidity-provider","title":"Liquidity Provider","text":"<p>A liquidity provider (LP), in the context of an DEX is a user who provides their liquidity to a liquidity pool or creates supply side orders such as limit order on a LOB to facilitate trading. </p> <p>For more info: https://www.gemini.com/cryptopedia/liquidity-provider-amm-tokens</p>"},{"location":"overview/glossary/#maker","title":"Maker","text":"<p>A maker is a user who provides assets upfront to facilitate trades with takers on an exchange. An example of a maker in crypto are liquidity providers.</p>"},{"location":"overview/glossary/#price-priority","title":"Price Priority","text":"<p>This is the description of a structure that prioritizes trades based on the lowest price when buying or the highest price when selling. This ensures that whether an asset is being bought or sold the party looking to market buy receives the best deal for them first.  </p> <p>For example:</p> <p>For sake of simplicity, we will use simple numbers and a small array of orders. If a user is buying ETH and selling DAI they may look at ETH-DAI orders on an orderbook.</p>"},{"location":"overview/glossary/#taker","title":"Taker","text":"<p>A taker is a user who trades with pre-existing assets provided by makers on an exchange.  </p>"},{"location":"overview/glossary/#trading-pair","title":"Trading Pair","text":"<p>A trading pair is the name of the pairing of assets. Typically pairs are named asset x - asset y and the number symbolizing price is presented as the amount of token x / per token y.  </p> <p>eg. ETH-DAI means the price of ETH in DAI  </p> <p>https://www.gemini.com/cryptopedia/what-are-cryptocurrency-pairs  </p>"},{"location":"overview/glossary/#price-tick","title":"Price Tick","text":"<p>A price tick is a discrete value that represents a range that is part of a virtual constant product curve. To help visualize this, think about changing a continuous constant-product curve into a discrete curve by separating it into individual price points.  </p> <p>The individual price points are the ticks A price tick also determines the accuracy of liquidity provision as if a virtual constant product curve.  </p> <p>Tick spacing is the price difference between each price tick. Between individual ticks there is a segmented piece of the constant product curve. The tick spacing is determined by the fee tier of the pool. </p> <p>The ticks are given numerical values starting at 0. To find what price value is attributed tick a value is attributed to and their width is given by the formula:</p> <p>price = ( 1 + z ) ^ n where z is the tick spacing in decimal form n is the numerical value for the price tick  </p> <p>eg. if you are trying to provide liquidity at a price of 1000 token x per token y, and the fee tier is 0.01%</p> <p>z = fee tier * 2 z = 0.0001 * 2 z = 0.0002  </p> <p>price = ( 1 + z ) ^ n 1000 = (1 + 0.0002) ^ n n = ln(1000) / ln(1.0002) n \u2248 34542</p> <p>The above values subbed back into the original formula show that you would be providing liquidity at the price point of 999.95 token x per token y. This is only an average of course as tick 34542 exists as its own constant product curve.</p>"},{"location":"overview/glossary/#time-weighted-average-price-twap","title":"Time Weighted Average Price (TWAP)","text":"<p>A time weighted average price (TWAP) is the average price a token is traded at over a period of time. Below is an example of a common TWAP formula:</p> <p></p> <p>Due to all transactions on a DEX being queryable on-chain a TWAP price can be calculated relatively simply by finding the timestamp and exchange rate for an asset over a certain period of time. Due to the ease of finding data and the calculation a TWAP price is seen as a simple way to create a price data source for a price oracle.</p> <p>The length of the time period the exchange rates are recorded over and ease of price manipulation have a negative relationship. This means that the longer the time period is the harder manipulation is.</p> <p>The cost to finding a TWAP price over a longer time period is that the TWAP will be less reactive to price changes and thus less accurate over a shorter period of time. In summary, for a given TWAP price relative to chosen the time period length the main dependent variables with a negative relationship are short term price accuracy and ease of manipulation.</p> <p></p>"},{"location":"overview/","title":"Overview","text":"<p>The Poolshark Protocol is a collection of noncustodial smart contracts that acts as a decentralized exchange offering both directional and bidirectional liquidity. By having directional support, LPs can properly express their views on a given pair and increase the liquidity available to the market at the same time.  </p> <p>Each type of position is placed within a liquidity pool and can be transacted via swaps. Having multiple LP types allows Poolshark to function as a hybrid of an automated market maker (AMM) and a limit order book (LOB) at once.</p> <p>The key difference between Poolshark and limit order books is that LOBs have an order queue while Poolshark merges all liquidity into a single pool, allowing for greater transaction throughput.</p> <p>With the Poolshark Protocol, AMMs have the addition of limit orders and stop-losses as a liquidity provider.</p> <p></p>"},{"location":"overview/#overview","title":"Overview","text":""},{"location":"overview/#what-problem-does-poolshark-address","title":"What Problem does Poolshark Address?","text":""},{"location":"overview/#indeterminate-pricing","title":"Indeterminate Pricing","text":"<p>For large institutions to use a spot exchange for everyday operations they must be able to provide a single asset to a position that allows them to set an immutable price and have irreversible execution. Given that current DEXes either deal with options, perpetuals, or AMMs which either don't allow for spot trading, create gas issues, or have execution that is reversible, the current DEXes on the market are unable to meet the needs of many institutions to move into providing assets on decentralized exchanges.</p>"},{"location":"overview/#merged-buy-and-sell-sides","title":"Merged buy and sell sides","text":"<p>Currently, most fully on-chain AMMs solely allow users to create bidirectional positions on a given pair moving along an invariant curve. This is something that inherently expresses the market view that the tokens in the pair will be priced relatively stable against one another.</p> <p>One of the features of the inherent design of an AMM from the viewpoint of a LP is when the price of an asset is changing relative to the other and the LP position is transacted with it changes to be comprised of more of the token that is decreasing in value. The reasoning for accepting this is due to transacting via swaps in either direction continuously the LP position accrues transaction fees from the users swapping in either direction with the liquidity pool.</p> <p>The issue with AMM pools is, given the scenario above, the greater of a price change the less the user is receiving relative to what the value of the assets they initially deposited are worth. This is a type of opportunity cost called impermanent loss. The reason it may be impermanent is if the price shifts or reverts back to the price at which the LP created their position, this loss will be eliminated. </p> <p>The price of the asset held in a position is determined by the demand for that asset relative to the other asset in a pair. Due to this if there is a lot of swapping into a certain asset in an AMM pool that asset will decrease in price.</p> <p>Poolshark addresses this by allowing LPs to choose from multiple types of positions to better reflect their beliefs on the market and manage their risk as they see fit. </p> <p>Poolshark employs three types of positions:</p> <ul> <li>Limit positions</li> <li>Cover positions</li> <li>Range positions</li> </ul> <p>Each of these positions is present in a different type of liquidity pool.</p> <p>Limit Pools can be viewed as a range-bound limit order.</p> <p>Cover Pools can be viewed as a range-bound stop loss which references the current TWAP.</p> <p>Range Pools can be viewed as a standard range-bound AMM pool with ERC-1155 support and easy autocompounding.</p> <p>Use cases for each can be observed on their respective pages. </p> <p>The team is excited to see new use cases found for each of the types of positions and we welcome your suggestions. </p> <p>With these added position types, liquidity providers can customize their risk profiles to match the current price action in the market.</p> <p>Directional liquidity allows for one-way fills similar to a traditional limit order, whereas current LP positions are reversible.</p> <p>DeFi protocols are often the largest liquidity providers in the ecosystem, so we're excited to see how our community and ecosystem can build solutions around protocols that are seeking to greatly improve their profitability and runway for the coming years.</p> <p>If you would like to contribute or have any questions, don't hesitate to open an issue on Github, or DM on Twitter</p> <p></p>"},{"location":"overview/#three-types-of-positions","title":"Three Types of Positions","text":""},{"location":"overview/#wrapping-up-the-overview","title":"Wrapping Up The Overview","text":""},{"location":"overview/indexes/","title":"Index","text":"<p>A -</p> <p>B -</p> <p>C -</p> <p>D -</p> <p>E -</p> <p>F -</p> <p>G -</p> <p>H -</p> <p>I -</p> <p>J -</p> <p>K -</p> <p>L -</p> <p>M - </p> <p>N -</p> <p>O -</p> <p>P -</p> <p>Q -</p> <p>R -</p> <p>S -</p> <p>T -</p> <p>U -</p> <p>V -</p> <p>W -</p> <p>X -</p> <p>Y -</p> <p>Z -</p>"},{"location":"overview/indexes/#index","title":"Index","text":""},{"location":"overview/limit-pools/","title":"Limit Pools","text":"<p>Limit Positions operate as a limit order consolidated to an invariant curve. The pool is used to collect the liquidity on a specific pair.</p> <p>The main difference is that there is a split buy and sell side.  The best priced liquidity for each respective trading direction is aggregated to be accessed first.</p> <p>This enables Limit Pools to enforce price priority.</p> <p> </p> <p>Limit Pools therefore allow users to undercut the current market price and receive prioritized execution for doing so.</p> <p>In offloading a large position before a large market move, it would be ideal to slightly undercut the market price.</p>"},{"location":"overview/limit-pools/#limit-pool-use-cases","title":"Limit Pool Use Cases","text":"<p>Use Case #1: Quick Exit/Entry Alice wants to sell ETH from 1998 to 1999.99 DAI per ETH. The current price of ETH is 2000 DAI per ETH.</p> <p> For this <code>Limit</code> position:</p> <ul> <li><code>lower</code> bound would be 1998</li> <li><code>upper</code> bound would be 1999.99</li> </ul> <p>This position would start offering up DAI to the market at a price of 1999 moving towards 1999.99 as their liquidity is filled. If this is the best price on the market, traders will naturally gravitate towards the Limit Pool in order to source their liquidity.</p> <p>It is key to have enough of a better price on the market to incentivise the volume to come and arbitrage vs the price offered by a Bidirectional AMM.</p> <p>If the depth of the liquidity isn't deep enough a market order will move to the liquidity offered by an AMM due to the high depth. </p> <p>This is great for large traders who are unwilling to accept slippage and paying for trading fees on the market, as they can wait until their liquidity is prioritized in order to capture the exact execution price they desire. In addition, due to being on the provider side the position will collect a premium (in the form of a trading fee) based on the fee tier of the order in the pool.</p> <p>In this case the average price ETH is sold at by Limit Pool is xx.xx DAI per ETH. In addition to this if the fee tier of the pool is 0.3% then we can take the average price sold and multiply it by (1 + fee tier) to get the average price sold inclusive of the premium. </p> <p>In summary: In this example Alice is better off providing liquidity to a Limit Pool than swapping due to collecting the fee instead of paying it and having a predetermined execution price instead of being subject to slippage.</p> <p>Mechanism to understand: <pre><code>- Choosing a Range Bound\n- Claiming Position Rewards\n</code></pre></p>"},{"location":"overview/limit-pools/#taking-profit","title":"Taking Profit","text":"<p>If you are seeking to take profit over some price range, Limit Pools are ideal given all the liquidity traded into your position will be retained. The <code>lower</code> and <code>upper</code> bound will mark the starting and ending price across which your position will trade from the input token to the output token.</p> <p>Users looking to exit at a predetermined price can create a limit pool position to do so.</p> <p></p>"},{"location":"overview/range-pools/","title":"Range Pools","text":"<p><code>Range Pools</code> are similar to what users have come to expect from AMMs while bounding liquidity between a price range.</p> <p>LPs can provide their liquidity to a specific price range, resulting in a higher concentration of liquidity and less slippage for swappers in comparison to AMM without price bounds. This is due to being able to have more liquidity within a specific range by not providing the Full Range of a constant product curve.</p> <p>The opportunity cost of providing liquidity to a constant function curve is commonly known as impermanent loss. Impermanent loss is intended to be hedged with the use of <code>Cover Pools</code></p> <p>Range Pools here have one unique feature improving composability with other DeFi protocols: <code>Default Ranges</code>. </p> <p></p> <p>Range Pools contain many small constant function curves between each price point, commonly referred to as a <code>Tick</code>. </p> <p>Each of the smaller price ranges will have reserves based on liquidity active within that <code>Tick</code>. </p> <p>Within each <code>Tick</code>, the pool functions exactly the same as what users have come to know from Constant Function Market Makers.</p> <p>Mechanism to understand: <pre><code>- Choosing a Range Bound\n- Claiming Position Liquidity\n- Claiming Fees Accrued\n</code></pre></p>"},{"location":"overview/range-pools/#choosing-a-range-bound","title":"Choosing a Range Bound","text":"<p>A position can also be bound to a <code>Full Range</code> which means that the position is bound from price 0 to \u221e so the price will always be within range for collecting fees,</p> <p>The variables that change with the width of your liquidity range are the depth of your liquidity, effects of impermanent loss and </p>"},{"location":"overview/range-pools/#volatile-pairs","title":"Volatile Pairs","text":"<p>The volatile category applies to most pairs where a project pairs ETH or a stablecoin against their native token.</p> <p>Provided the liquidity is <code>range-bound</code>, the magnitude of impermanent loss will be greater. For a <code>range-bound</code> position on a low volume pair, it\u2019s very unlikely that the gains from trading fees will exceed the loss from impermanent loss.</p> <p>Further, <code>range-bounding</code> liquidity on a volatile pair runs the risk of your position falling out of range. If your position falls out of range, you\u2019ll need to rebalance. Rebalancing costs you in swap fees, slippage and gas.</p> <p>To cover the costs of rebalancing one's liquidity position, we recommend a <code>Cover</code> position to cover impermanent loss with directional liquidity profits.</p>"},{"location":"overview/range-pools/#pegged-pairs","title":"Pegged Pairs","text":"<p>Pegged pairs, though not completely eliminating the risk of impermanent loss, often result in minimal IL. For lower volume pairs, LPs might want to increase the range slightly on each side.</p>"},{"location":"overview/range-pools/#anchored-pairs","title":"Anchored Pairs","text":"<p>Anchored in this context describes asset pairs that move predictably and steadily in price relative to one another.</p> <p>WETH and rETH from <code>Rocket Pool</code> is a great example here. If rETH returns 10% annually relative to WETH, we could deploy a liquidity mining program on a narrow, concentrated range of liquidity, adding 10% to the upside as a buffer. This position would likely remain in range for a full year maintaining a high degree of capital efficiency \u2014 without any rebalance required.</p>"},{"location":"overview/range-pools/#claiming-position-liquidity","title":"Claiming Position Liquidity","text":"<p>Depending on the current price of the pool, the user will be able to withdraw their position accordingly:</p> <ul> <li><code>price</code> &lt; user's <code>lower</code> tick: 100% of user liquidity will be in <code>token0</code></li> <li><code>price</code> &gt; user's <code>upper</code> tick: 100% of user liquidity will be in <code>token1</code></li> <li><code>price</code> &gt; user's <code>lower</code> tick AND <code>price</code> &lt; user's <code>upper</code> tick: a mix of the user's liquidity will be both in <code>token0</code> and <code>token1</code></li> </ul>"},{"location":"overview/range-pools/#claiming-fees-accrued","title":"Claiming Fees Accrued","text":"<p>The way in which <code>Range Pools</code> track how much of the user's position has been filled is by using the value <code>feeGrowthGlobal</code>. Depending on where the current tick is will determine what liquidity is withdrawn from the pool.</p> <p>Fee accounting is tracked with the <code>feeGrowthGlobal0</code> and <code>feeGrowthGlobal1</code> values present on the <code>upper</code> and <code>lower</code> tick representing the user's Position. Global fees generated represent 1 unit of liquidity, so to get the fees belonging to a single <code>Position</code>, we will multiply by that <code>Position</code>'s liquidity amount. </p> <p>Fees accumulated outside of a price range are tracked when a tick is crossed. This allows us to simply calculate fees accumulated below the lower tick and then fees calculated above the upper tick.</p> <p><code>feeGrowthGlobal0</code> and <code>feeGrowthGlobal1</code> are on a per liquidity unit basis, so this value is simply multiplied by the amount of liquidity contained in a Position to determine the fees owed to that specific Position.</p> <p></p>"},{"location":"protocol-guide/fees/","title":"Fees","text":"<p>The fee system for the protocol is based on static fee tiers. Fee priority is based on how tight the range for a <code>Concentrated Liquidity Position</code> is. The individual LP fee accrual after a swap is attributed based on these two parameters. Fee tiers are expressed in <code>Basis Points</code> (e.g. 1 <code>Basis Point</code> represents 1/100 of 1%, or 0.01% of the used liquidity for a given swap). When creating a new position the LP/maker will be able to choose between one of the following fee tiers:</p>"},{"location":"protocol-guide/fees/#current-fee-tiers","title":"Current Fee Tiers","text":"<ul> <li>1 <code>Basis Point</code></li> <li>5 <code>Basis Points</code></li> <li>10 <code>Basis Points</code></li> <li>100 <code>Basis Points</code> </li> </ul>"},{"location":"protocol-guide/oracles/","title":"Oracles","text":""},{"location":"protocol-guide/oracles/#why-use-oracles","title":"Why use oracles?","text":"<p>Oracles are crucial for the proper functioning of the protocol since accurate and up-to-date price quotes are needed to assure the final exchange in a swap is respected according to the swap quote the end user is getting for taking liquidity.</p>"},{"location":"protocol-guide/oracles/#what-is-twap","title":"What is TWAP?","text":"<p><code>TWAP</code> stands for <code>Time Weighted Average Price</code> which is the measure of an assets' average price over a given time interval. The goal of using <code>TWAP</code> is optimizing a trade's average price over the course of the selected time interval.</p>"},{"location":"protocol-guide/oracles/#how-does-it-work","title":"How does it work?","text":"<p>The oracle will track the cumulative logarithmic sum between the current price tick and the first tick in the selected time interval in a <code>Geometric Mean TWAP</code>. In other words, the current price is derived from an arithmetic sum mean. To determine this mean, two observations are retrieved and the difference is obtained by subtracting the first observation from the current one and dividing said result by the elapsed time. </p> <p> </p>"},{"location":"protocol-guide/swaps/","title":"Swaps","text":""},{"location":"protocol-guide/swaps/#how-is-a-swap-executed","title":"How is a swap executed?","text":"<ul> <li>Taker chooses token pair to perform swap</li> <li>Taker requests swap transaction</li> <li>Liquidity is aggregated from several <code>Concentrated Liquidity Positions</code> and respective ticks</li> <li>Order is filled according to the average price quote from said ticks</li> <li>Liquidity gets taken from all LPs/makers according to how tight their liquidity range is (e.g. tighter liquidity ranges will be prioritized for providing liquidity for the swap)</li> <li>Individual end LPs/makers that provided liquidity for the given swap get fees according to their selected <code>Fee Tier</code></li> </ul>"},{"location":"protocol-guide/liquidity-providers/directional-liquidity/","title":"Directional Liquidity","text":""},{"location":"protocol-guide/liquidity-providers/directional-liquidity/#how-do-i-create-a-directional-liquidity","title":"How do I create a Directional Liquidity ?","text":"<p><code>Directional Liquidity</code> refers to the direction the LP is going to take when entering a pool (eg. from <code>ETH</code> to <code>DAI</code>). It's similar to <code>Concentrated Liquidity</code> in the way that makers provide liquidity for a given price range, but differs by taking <code>Single-Sided Liquidity</code>, i.e. the liquidity curve only moves one way for the asset provided.</p>"},{"location":"protocol-guide/liquidity-providers/directional-liquidity/#what-is-the-main-goal-of-using-it","title":"What is the main goal of using it?","text":"<p>By providing liquidity in a certain direction, users are able to benefit from the <code>Impermanent Loss</code> reduction that <code>Single-Sided Liquidity</code> brings by not needing to deposit an equal ratio of assets both ways and thus being subject to losses due to said ratio changing over time.</p>"},{"location":"protocol-guide/liquidity-providers/directional-liquidity/#how-does-it-work","title":"How does it work?","text":"<p>Let's say a <code>Liquidity Provider</code> wants to deposit 1 ETH to DAI in a pool from 1400 to 1200 DAI with a fee tier of 5 <code>Basis Points</code>. If a trader wants to swap <code>ETH</code> into <code>DAI</code> in this price range, the LP will get priority over other LPs with bigger ranges for this price direction. If the LPs' liquidity is used in the swap the 5 BP over the amount of tokens swapped will be accrued as fees (e.g. if a user swaps 10 ETH into DAI and there is enough liquidity to fill the order the LP will take at least 60 <code>DAI</code> and at most <code>70</code> DAI assuming the minimum and maximum prices of the range are maintained).</p>"},{"location":"protocol-guide/liquidity-providers/directional-range-order/","title":"Directional Range Orders","text":"<p>Using the previously announced concepts, a <code>Directional Range Order</code> puts together <code>Range Orders</code> and <code>Directional Liquidity</code> in order to have specific LP price ranges for orders in single-sided asset pools. </p>"},{"location":"protocol-guide/liquidity-providers/directional-range-order/#main-benefits","title":"Main benefits","text":"<ul> <li>Significant slippage reduction</li> <li>Mitigation of <code>Impermanent Loss</code> outside of the assets' inherent price volatility</li> </ul>"},{"location":"protocol-guide/liquidity-providers/single-sided/","title":"Single Sided Liquidity","text":""},{"location":"protocol-guide/liquidity-providers/single-sided/#what-is-single-sided-liquidity","title":"What is Single-Sided Liquidity?","text":"<p><code>Single-Sided Liquidity</code> refers to non-paired liquidity provisioning. Usual liquidity pools powered by AMMs require a liquidity provider to deposit an equal stake of a pair of tokens (<code>Double-Sided Liquidity</code>), while <code>Single-Sided Pools</code> just require the target token to be deposited, granting LP fees that are paid in that same token.</p>"},{"location":"protocol-guide/liquidity-providers/single-sided/#how-does-single-sided-liquidity-work","title":"How does Single-Sided Liquidity work?","text":"<p>By depositing a single token and not a bound pair, there is no balance ratio of the LPs tokens to adjust according to takers' behaviour and as such <code>Impermanent Loss</code> is mitigated and only dependent on the assets' inherent price fluctuations. </p> <p> </p> Conventional double-sided LP <p> </p>"},{"location":"references/automated-market-makers/","title":"Automated Market Makers","text":"<ol> <li> <p>Slippage in AMM Markets</p> </li> <li> <p>Impermanent Loss and Price Discovery: Are Automated Market Makers a Sustainable Exchange Model? </p> <ul> <li>by Jonathan Choong Bachelor of Business (Honours), UTS Business School</li> </ul> </li> <li> <p>Automated Market Making and Loss-Versus-Rebalancing </p> <ul> <li>by Anthony Lee Zhang, University of Chicago Booth of Business</li> </ul> </li> </ol>"},{"location":"references/limit-order-books/","title":"Limit Order Books","text":"<ol> <li> <p>The Value of Queue Position in a Limit Order Book </p> <ul> <li>by Ciamac C. Moallemi and Kai Yuan; Columbia University Graduate School of Business</li> </ul> </li> <li> <p>Trading Fees and Efficiency in Limit Order Markets </p> <ul> <li>Centre for Economic Policy Research</li> </ul> </li> <li> <p>Optimal Auction Duration: A price formation viewpoint </p> <ul> <li>Ecole Polytechnique, CMAP</li> </ul> </li> <li> <p>An Open-Source Limit-Order-Book Exchange for Teaching and Research </p> <ul> <li>Dave Cliff, Dept. of Computer Science, University of Bristol</li> </ul> </li> <li> <p>Is the Electronic Open Limit Order Book Inevitable? </p> <ul> <li>Lawrence R. Glosten, The Journal of Finance</li> </ul> </li> <li> <p>Limit Order Book Transparency, Execution Risk, and Market Liquidity </p> <ul> <li>School of Business, University of Sydney</li> </ul> </li> <li> <p>Limit orders and slippage resistance in x*y=k market makers </p> <ul> <li>Hayden Adams, Uniswap Labs</li> </ul> </li> <li> <p>Token sales and shorting </p> <ul> <li>Vitalik Buterin, Ethereum Foundation</li> </ul> </li> </ol>"},{"location":"smart-contracts/overview/","title":"Overview","text":"<p>Poolshark is a set of smart contracts comprising support for range liquidity, cover liquidity, and price liquidity.</p> <p>The smart contract's base purpose is to provide fundamental guarantees for all interfacing parties. They define the logic to permissionlessly create new pools, adding liquidity, executing swaps, accumulating across ticks, etc.</p>"},{"location":"smart-contracts/overview/#cover-pools","title":"Cover Pools","text":"<p>Cover Factory Reference</p> <p>The factory defines the logic for generating <code>Cover Pools</code>. A pool is defined by two tokens and a volatility tier. Multiple pools of the same pair can exist, distinguished by the input pool being tracked as well as the auction parameters (i.e. <code>tickSpread</code>, <code>twapLength</code>, and <code>auctionLength</code>).</p> <p>Cover Pool Reference</p> <p>Cover Pools allow liquidity providers to increase exposure when token price is increasing and decrease exposure when token price is decreasing.</p> <p>Cover Solidity Contracts</p>"},{"location":"smart-contracts/overview/#limit-pools","title":"Limit Pools","text":"<p>Limit Factory Reference</p> <p>The factory defines the logic for generating <code>Limit Pools</code>. A pool is defined by two tokens. <code>Limit Pools</code> differ from <code>Range Pools</code> in that LP positions only trade in one direction.</p> <p>Limit Pool Reference</p> <p><code>Limit Pools</code> allow liquidity providers to decrease exposure when token price is increasing.</p> <p>Limit Solidity Contracts (open-source soon) </p>"},{"location":"smart-contracts/overview/#range-pools","title":"Range Pools","text":"<p>Range Factory Reference</p> <p>The factory defines the logic for generating <code>Range Pools</code>. A range pool is defined by two tokens, which make up the asset pair, and a fee tier. Multiple pools of the same pair can exist, distinguished by each fee tier in existence.</p> <p>Range Pool Reference</p> <p>Range Pools allow liquidity providers to have fungible two-way liquidity and autocompounding.</p> <p>Samples Reference</p> <p>The <code>Samples</code> library allows for on-chain price and liquidity oracle data to be aggregated for a wide variety of use cases both on-chain and off-chain.  is turned off by default in all <code>Range Pools</code> and is automatically expanded via <code>Cover Pools</code> as needed.</p> <p>Range Solidity Contracts</p> <p></p>"},{"location":"smart-contracts/base/PoolsharkLimitFactory/","title":"PoolsharkLimitFactory","text":"<p>Launches Poolshark price pools, manages ownership controls, fee accrual, and user positions. </p>"},{"location":"smart-contracts/base/PoolsharkLimitFactory/#functions","title":"Functions","text":""},{"location":"smart-contracts/base/PoolsharkLimitFactory/#createbook","title":"createBook","text":"<pre><code>  function createBook(\naddress token20A,\naddress token20B,\nuint24 feeTier,\nuint256 makerTier\n) external returns (address pool)\n</code></pre> <p>Creates a book for the given two ERC-20 tokens and fee tier.</p> <p>A book differs from a pool in that liquidity is not reused like in a pool.</p> <p>Books support pro-rata fills, however there is still price priority, thus filling the lowest price tick first.</p> <p>The addresses of <code>token20A</code> and <code>token20B</code> will be sorted lexographically (i.e. first by number then by letter) based on their addresses.</p> <p>This will correspond to <code>token0</code> and <code>token1</code> in the book created. </p> <p><code>tickSpacing</code> is retrieved based on the fee tier selected. The contract call will revert if the book already exists, the fee or maker tier is not supported, or the token addresses are invalid.</p> <p> Parameters: </p> Name Type Description <code>token20A</code> address The first ERC-20 token to pair in the book <code>token20B</code> address The second ERC-20 token to pair in the book <code>feeTier</code> uint24 The selected fee tier for the book <code>makerTier</code> uint256 The select maker tier defining the minimum order size <p> Return Values: </p> Name Type Description <code>book</code> address The generated address for the token book"},{"location":"smart-contracts/base/PoolsharkLimitFactory/#setowner","title":"setOwner","text":"<pre><code>  function setOwner(\naddress _owner\n) external\n</code></pre> <p>Sets the owner of the factory contract.</p> <p>The <code>owner</code> is set to <code>msg.sender</code> when the factory contract is first launched.</p> <p>Admin functions: <code>setOwner</code> <code>enableFeeTier</code></p> <p> Parameters: </p> Name Type Description <code>_owner</code> address The new owner of the factory"},{"location":"smart-contracts/base/PoolsharkLimitFactory/#enablefeetier","title":"enableFeeTier","text":"<pre><code>  function enableFeeTier(\nuint24 feeTier,\nint24 tickSpacing\n) public\n</code></pre> <p>Enables a fee tier with the selected tickSpacing and makerSize.</p> <p>Fee amounts can never be removed by anyone once enabled.</p> <p> Parameters: </p> Name Type Description <code>feeTier</code> uint24 The fee amount to enable, denominated in hundredths of a basis points (i.e. 0.0001%) <code>tickSpacing</code> int24 The spacing between ticks to be enforced for all books created with the given fee amount denoted in basis points (i.e. 0.01%)"},{"location":"smart-contracts/base/PoolsharkLimitFactory/#enablemakertier","title":"enableMakerTier","text":"<pre><code>  function enableFeeTier(\nuint24 feeTier,\nuint256 makerTier\n) public\n</code></pre> <p>Enables a maker tier with the selected tick spacing and fee tier.</p> <p>Maker tiers exist to provide deterministic gas costs for liquidity takers. This prevents makers from keeping the price artificially low with tiny amounts of liquidity.</p> <p>Maker tiers can never be removed by anyone once enabled.</p> <p> Parameters: </p> Name Type Description <code>feeTier</code> uint24 The fee amount to enable, denominated in hundredths of a basis points (i.e. 0.0001%) <code>makerTier</code> uint256 The minimum order size for which smaller orders will be rejected to maintain deterministic gas costs for the taker <p> </p>"},{"location":"smart-contracts/base/PoolsharkLimitPair/","title":"PoolsharkLimitPair","text":"<p>A queue of orders which enforces price-time priority fills.</p> <p>Each <code>Page</code> is a price tick that contains a collection of orders.</p> <p><code>Offsets</code> are used to track which maker orders have been filled.</p>"},{"location":"smart-contracts/base/PoolsharkLimitPair/#functions","title":"Functions","text":""},{"location":"smart-contracts/base/PoolsharkLimitPair/#getpageprice","title":"getPagePrice","text":"<pre><code>    function getPagePrice(\naddress takerToken,\nuint256 takerAmount,\nuint256 makerAmount\n) public view returns (uint256 pagePrice)\n</code></pre> <p>Returns the <code>pagePrice</code> given the token being swapped in as well as the <code>takerAmount</code> and <code>makerAmount</code>.</p> <p> Parameters: </p> Name Type Description <code>takerToken</code> address The token being swapped in <code>takerAmount</code> uint256 The amount of the token swapped in or received by the liquidity provider <code>makerAmount</code> uint256 The amount of the token swapped into or provided by the liquidity provider <p> Return Values: </p> Name Type Description <code>pagePrice</code> uint256 the value of the page price based on the input amounts"},{"location":"smart-contracts/base/PoolsharkLimitPair/#getpagekey","title":"getPageKey","text":"<pre><code>    function getPageKey(\naddress takerToken,\nuint256 takerAmount,\nuint256 makerAmount\n) public view returns (bytes32)\n</code></pre> <p>Returns the <code>pageKey</code> given the token being swapped in (i.e. <code>takerToken</code>) as well as the <code>takerAmount</code> and <code>makerAmount</code>.</p> <p> Parameters: </p> Name Type Description <code>takerToken</code> address The token being swapped in <code>takerAmount</code> uint256 The amount of the token swapped in or received by the liquidity provider <code>makerAmount</code> uint256 The amount of the token swapped into or provided by the liquidity provider <p> Return Values: </p> Name Type Description <code>pageKey</code> bytes32 the key in the <code>pages</code> mapping used to lookup the <code>Page</code>"},{"location":"smart-contracts/base/PoolsharkLimitPair/#getorderkey","title":"getOrderKey","text":"<pre><code>    function getOrderKey(\naddress owner,\nbytes32 pageKey,\nuint256 endOffset\n) public pure returns (bytes32)\n</code></pre> <p>Returns the <code>orderKey</code> given the <code>owner</code> address as well as the <code>pageKey</code> and <code>endOffset</code>.</p> <p> Parameters: </p> Name Type Description <code>owner</code> address The token being swapped in <code>pageKey</code> uint256 The page key for which the <code>Order</code> is linked to <code>endOffset</code> uint256 The offset representing the end of the <code>Order</code> <p> Return Values: </p> Name Type Description <code>orderKey</code> bytes32 the key in the <code>orders</code> mapping used to lookup the <code>Order</code>"},{"location":"smart-contracts/base/PoolsharkLimitPair/#limitorder","title":"limitOrder","text":"<pre><code>    function limitOrder(\naddress fromToken,\nuint256 fromAmount,\nuint256 destAmount,\nuint256 limitPrice,\nbool makerOnly,\nbool takerOnly\n) public returns (uint256 fromAmountIn, uint256 destAmountOut)\n</code></pre> <p>Executes or creates a limit order. If <code>makerOnly</code> is set to <code>true</code>, liquidity will be added to the book to collect fees from swappers. If <code>takerOnly</code> is set to <code>true</code>, liquidity will only be taken from the book (i.e. normal <code>swap</code> call).</p> <p>Note: a token <code>approve()</code> call required prior with the amount <code>fromAmount</code>. </p> <p> Parameters: </p> Name Type Description <code>fromToken</code> address The address of the token being swapped in <code>fromAmount</code> uint256 The max amount of <code>fromToken</code> to be spent <code>destAmount</code> uint256 The max of <code>destToken</code> to be received <code>limitPrice</code> uint256 The max <code>pagePrice</code> to pull liquidity from <code>makerOnly</code> bool Default false; set true to force liquidity add <code>takerOnly</code> bool Default false; set true to force liquidity swap <p> Return Values: </p> Name Type Description <code>fromAmountIn</code> uitn256 the amount of <code>fromToken</code> transferred into the contract <code>destAmountOut</code> uitn256 the amount of <code>destToken</code> transferred to the recipient"},{"location":"smart-contracts/base/PoolsharkLimitPair/#claimorders","title":"claimOrders","text":"<pre><code>    function claimOrders(\nuint256[] memory pagePrices,\nuint256[] memory endOffsets,\naddress[] memory takerTokens,\nuint256[] memory amounts\n    ) external </code></pre> <p>Claims an executed limit order(s). If <code>amount</code> is greater than the actual amount in the order, the entire amount will be claimed.</p> <p> Parameters: </p> Name Type Description <code>pagePrices</code> uint256[] An array of <code>pagePrice</code> values for the orders being claimed <code>endOffsets</code> uint256[] The page key for which the <code>Order</code> is linked to <code>amounts</code> uint256[] The offset representing the end of the <code>Order</code> <p> Return Values: </p> Name Type Description <code>amountsCancelled</code> uint256[] the amount of <code>takerToken</code> transferred back to the recipient"},{"location":"smart-contracts/base/PoolsharkLimitPair/#cancelorders","title":"cancelOrders","text":"<pre><code>    function cancelOrders(\nbytes32[] pageKey,\nuint256[] endOffset,\nuint256[] amount\n    ) public returns (uint256[] amountsCancelled)\n</code></pre> <p>Cancels an existing limit order(s). If <code>amount</code> is greater than the actual amount in the order, the entire order will be cancelled. </p> <p>Note: If the amount left in the order would be less than the <code>makerTier</code>, the minimum order size, the order will remain unmodified.</p> <p> Parameters: </p> Name Type Description <code>pageKeys</code> address[] The page keys of the orders being cancelled <code>endOffsets</code> uint256[] The end offset of each <code>Order</code> being cancelled <code>amounts</code> uint256[] The amounts being cancelled from each <code>Order</code> <p> Return Values: </p> Name Type Description <code>amountsCancelled</code> uint256[] the amount of <code>makerToken</code> transferred back to the recipient"},{"location":"smart-contracts/base/PoolsharkLimitPair/#quoteexactamountout","title":"quoteExactAmountOut","text":"<pre><code>    function quoteExactAmountOut(\naddress fromToken,\nuint256 fromAmount,\nuint256 limitPrice\n) public view returns (uint256 fromAmountIn, uint256 destAmountOut)\n</code></pre> <p>Gives a quote based on the <code>fromAmount</code> desired and the liquidity in the book.</p> <p>Liquidity will be checked up to and including the specified <code>limitPrice</code>.</p> <p> Parameters: </p> Name Type Description <code>fromToken</code> address The token that would be passed in for a swap <code>fromAmount</code> uint256 The amount of <code>fromToken</code> that would be transferred in <code>limitPrice</code> uint256 The <code>pagePrice</code> value to swap up to <p> Return Values: </p> Name Type Description <code>fromAmountIn</code> uitn256 the amount of <code>fromToken</code> that can be transferred into the contract <code>destAmountOut</code> uitn256 the amount of <code>destToken</code> that will be transferred to the recipient"},{"location":"smart-contracts/base/PoolsharkLimitPair/#quoteexactamountin","title":"quoteExactAmountIn","text":"<pre><code>    function quoteExactAmountIn(\naddress destToken,\nuint256 destAmount,\nuint256 limitPrice\n) public view returns (uint256 fromAmountIn, uint256 destAmountOut)\n</code></pre> <p>Gives a quote based on the <code>destAmount</code> desired and the liquidity in the book.</p> <p>Liquidity will be checked up to and including the specified <code>limitPrice</code>.</p> <p> Parameters: </p> Name Type Description <code>destToken</code> address The token that would be received from a swap <code>destAmount</code> uint256 The amount of <code>destToken</code> that would be transferred in <code>limitPrice</code> uint256 The <code>pagePrice</code> value to swap up to <p> Return Values: </p> Name Type Description <code>fromAmountIn</code> uitn256 the amount of <code>fromToken</code> that can be transferred into the contract <code>destAmountOut</code> uitn256 the amount of <code>destToken</code> that will be transferred to the recipient"},{"location":"smart-contracts/cover/CoverPool/","title":"CoverPool","text":"<p>Manages cover liquidity positions.</p>"},{"location":"smart-contracts/cover/CoverPool/#functions","title":"Functions","text":""},{"location":"smart-contracts/cover/CoverPool/#mint","title":"mint","text":"<p><pre><code>    function mint(\nMintParams memory params\n    ) external lock\n\nstruct MintParams {\naddress to;\nuint128 amount;\nint24 lower;\nint24 claim;\nint24 upper;\nbool zeroForOne;\n}\n</code></pre> Mints a Cover LP for the range <code>lower</code> to <code>upper</code>.</p> <p><code>lower</code> will be the lower price tick for the position.</p> <p><code>upper</code> will be the upper tick for the position.</p> <p>Both <code>lower</code> and <code>upper</code> must be multiples of the <code>tickSpread</code> for the pool.</p> <p><code>claim</code> only need be an exact value in the case the user has already minted a position with the same <code>lower</code> and <code>upper</code>.</p> <p>If this is the case, the <code>claim</code> tick must be the furthest tick crossed into the position.</p> <p><code>zeroForOne</code> as <code>true</code> means the LP deposits <code>token0</code> and is filled with <code>token1</code>. <code>zeroForOne</code> as <code>false</code> means the LP deposits <code>token1</code> and is filled with <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>to</code> int24 The recipient of the fungible position <code>lower</code> int24 The lower price tick of the range <code>claim</code> int24 The claim price tick of the range <code>upper</code> int24 The upper price tick of the range <code>amount</code> uint128 The amount of the input token to add to the <code>Position</code> <code>zeroForOne</code> bool <code>true</code> for <code>token0</code> =&gt; <code>token1</code> and <code>false</code> for <code>token1</code> =&gt; <code>token0</code> <p> Return Values: </p> Name Type Description <code>amount</code> uint256 The amount of the input token that was added to mint liquidity."},{"location":"smart-contracts/cover/CoverPool/#burn","title":"burn","text":"<pre><code>    function burn(\nBurnParams memory params\n    ) external lock\n\nstruct BurnParams {\naddress to;\nuint128 burnPercent;\nint24 lower;\nint24 claim;\nint24 upper;\nbool zeroForOne;\nbool sync;\n}\n</code></pre> <p>Burns liquidity from <code>msg.sender</code>. The token received from the burned liquidity is then sent to the address <code>to</code>.</p> <p><code>burnPercent</code> is a number no greater than <code>1e38</code> which equals 100%.</p> <p><code>lower</code> and <code>upper</code> must match a position owned by the caller.</p> <p><code>zeroForOne</code> will be <code>true</code> if the LP is trading <code>token1</code> for <code>token0</code> and <code>false</code> if the LP is trading <code>token1</code> for <code>token0</code>.</p> <p><code>sync</code> should be <code>true</code> in most cases to receive the <code>syncFee</code> if available. <code>false</code> should only be used if the user wants to exit their LP without syncing the pool.</p> <p> Parameters: </p> Name Type Description <code>to</code> int24 The recipient of the token from the burned liquidity <code>burnPercent</code> uint128 The percent of the user's liquidity to be burned and collected (1e38 = 100%) <code>lower</code> int24 The lower price tick of the range <code>claim</code> int24 The claim price tick of the range <code>upper</code> int24 The upper price tick of the range <code>zeroForOne</code> bool <code>true</code> for <code>token0</code> =&gt; <code>token1</code> and <code>false</code> for <code>token1</code> =&gt; <code>token0</code> <code>zeroForOne</code> bool <code>true</code> to allow sync and <code>false</code> to skip sync <p> Return Values: </p> Name Type Description <code>amount0</code> uint256 The amount of token0 collected for burning liquidity. Matches the value in the callback <code>amount1</code> uint256 The amount of token1 collected for burning liquidity. Matches the value in the callback"},{"location":"smart-contracts/cover/CoverPool/#swap","title":"swap","text":"<pre><code>    function swap(\naddress recipient,\nbool zeroForOne,\nuint256 amountIn,\nuint160 priceLimit\n) external override lock\n</code></pre> <p>Swaps <code>token0</code> for <code>token1</code> or <code>token1</code> for <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>recipient</code> address The address to receive the output of the swap <code>zeroForOne</code> bool The direction of the swap, true for <code>token0</code> =&gt; <code>token1</code>, false for <code>token1</code> =&gt; <code>token0</code> <code>amountIn</code> int256 The token amount for the swap <code>priceLimit</code> uint160 The Q64.96 sqrt price limit. If <code>zeroForOne</code> is true, the price cannot be less than this value after the swap. If <code>zeroForOne</code> is false, the price cannot be greater than this value after the swap. <code>data</code> bytes Raw data being passed through to the callback"},{"location":"smart-contracts/cover/CoverPool/#quote","title":"quote","text":"<pre><code>    function quote(\naddress recipient,\nbool zeroForOne,\nuint256 amountIn,\nuint160 priceLimit\n) external override lock\n</code></pre> <p>Swap <code>token0</code> for <code>token1</code>, or <code>token1</code> for <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>recipient</code> address The address to receive the output of the swap <code>zeroForOne</code> bool The direction of the swap, true for <code>token0</code> =&gt; <code>token1</code>, false for <code>token1</code> =&gt; <code>token0</code> <code>amountIn</code> int256 The token amount for the swap <code>priceLimit</code> uint160 The Q64.96 sqrt price limit. If <code>zeroForOne</code> is true, the price cannot be less than this value after the swap. If <code>zeroForOne</code> is false, the price cannot be greater than this value after the swap. <code>data</code> bytes Raw data being passed through to the callback <p> Return Values: </p> Name Type Description <code>amount0</code> uint128 The change in the pool <code>token0</code> balance <code>amount1</code> uint128 The change in the pool <code>token1</code> balance"},{"location":"smart-contracts/cover/CoverPool/#collectprotocolfees","title":"collectProtocolFees","text":"<pre><code>    function protocolFees(\nuint16 syncFee,\nuint16 fillFee,\nbool setFees\n) external ownerOnly returns (\nuint128 token0Fees,\nuint128 token1Fees\n)\n</code></pre> <p>Collect the protocol fees accrued by the pool.</p> <p> Parameters: </p> <p> Return Values: </p> Name Type Description <code>token0Fees</code> uint128 The protocol fee collected in token0 <code>token1Fees</code> uint128 The protocol fee collected in token1 <p> </p>"},{"location":"smart-contracts/cover/CoverPoolFactory/","title":"CoverPoolFactory","text":"<p>Creates and gets cover pools. </p>"},{"location":"smart-contracts/cover/CoverPoolFactory/#functions","title":"Functions","text":""},{"location":"smart-contracts/cover/CoverPoolFactory/#createcoverpool","title":"createCoverPool","text":"<p><pre><code>    function createCoverPool(\nbytes32 sourceName,\naddress tokenIn,\naddress tokenOut,\nuint16 feeTier,\nint16  tickSpread,\nuint16 twapLength\n) external override returns (address pool)\n</code></pre> Creates a pool for the given two ERC-20 tokens to correspond with an existing volatility tier.</p> <p>The volatility tier selected is based on the <code>sourceName</code>, <code>feeTier</code>, <code>tickSpread</code>, and <code>twapLength</code> passed in.</p> <p>The addresses of <code>tokenIn</code> and <code>tokenOut</code> will have their addresses sorted lexicographically (i.e. first by number then by letter) to represent <code>token0</code> and <code>token1</code>.</p> <p>The contract call will revert with <code>PoolAlreadyExists()</code> if the pool already exists, <code>TwapSourceNotFound</code> is the TWAP source does not exists, <code>VolatilityTierNotSupported()</code> if the volatility tier is not supported, or <code>InvalidTokenAddress</code> if one of the token addresses is invalid.</p> <p> Parameters: </p> Name Type Description <code>sourceName</code> bytes32 A bytes string with the name of the TWAP source being used (e.g. 'UNI-V3') <code>tokenIn</code> address The first ERC-20 token by ordering in the pool <code>tokenOut</code> address The second ERC-20 token by ordering in the pool <code>feeTier</code> uint16 The selected fee tier from which to derive TWAP data <code>tickSpread</code> int16 The spacing for the ticks which will create a spread around the TWAP <code>twapLength</code> uint16 The length in seconds for the TWAP sample which matches a volatility tier <p> Return Values: </p> Name Type Description <code>pool</code> address The generated address for the pool"},{"location":"smart-contracts/cover/CoverPoolFactory/#getcoverpool","title":"getCoverPool","text":"<pre><code>    function getCoverPool(\nbytes32 sourceName,\naddress tokenIn,\naddress tokenOut,\nuint16 feeTier,\nint16  tickSpread,\nuint16 twapLength\n) external view override returns (address)\n</code></pre> <p>Gets the pool for the given two ERC-20 tokens with the selected fee tier.</p> <p>If such a pool does not exist, <code>address(0)</code> will be returned.</p> <p> Parameters: </p> Name Type Description <code>sourceName</code> bytes32 A bytes string with the name of the TWAP source being used (e.g. 'UNI-V3') <code>tokenIn</code> address The first ERC-20 token by ordering in the pool <code>tokenOut</code> address The second ERC-20 token by ordering in the pool <code>feeTier</code> uint16 The selected fee tier from which to derive TWAP data <code>tickSpread</code> int16 The spacing for the ticks which will create a spread around the TWAP <code>twapLength</code> uint16 The length in seconds for the TWAP sample which matches a volatility tier <p> Return Values: </p> Name Type Description <code>pool</code> address The address of the found pool (if exists) <p> </p>"},{"location":"smart-contracts/libraries/BitMath/","title":"BitMath","text":"<p>This library provides functionality for computing bit properties of an unsigned integer</p>"},{"location":"smart-contracts/libraries/BitMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/BitMath/#mostsignificantbit","title":"mostSignificantBit","text":"<pre><code>  function mostSignificantBit(\nuint256 value\n) internal pure returns (uint8 index)\n</code></pre> <p>Returns the index of the most significant bit of the number, where the least significant bit is at index 0 (i.e. rightmost bit) and the most significant bit is at index 255 (i.e. leftmost bit).</p>"},{"location":"smart-contracts/libraries/BitMath/#parameters","title":"Parameters:","text":"Name Type Description <code>value</code> uint256 the value for which to compute the most significant bit, must be greater than 0"},{"location":"smart-contracts/libraries/BitMath/#return-values","title":"Return Values:","text":"Name Type Description <code>index</code> unit8 the index of the most significant bit"},{"location":"smart-contracts/libraries/BitMath/#leastsignificantbit","title":"leastSignificantBit","text":"<pre><code>  function leastSignificantBit(\nuint256 value\n) internal pure returns (uint8 index)\n</code></pre> <p>Returns the index of the least significant bit of the number, where the least significant bit is at index 0 (i.e. rightmost bit) and the most significant bit is at index 255 (i.e. leftmost bit).</p>"},{"location":"smart-contracts/libraries/BitMath/#parameters_1","title":"Parameters:","text":"Name Type Description <code>value</code> uint256 the value for which to compute the least significant bit, must be greater than 0"},{"location":"smart-contracts/libraries/BitMath/#return-values_1","title":"Return Values:","text":"Name Type Description <code>index</code> unit8 the index of the least significant bit"},{"location":"smart-contracts/libraries/FullMath/","title":"FullMath","text":"<p>Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.                                                                                                                     </p> <p>Handles \"phantom overflow\" and prevents overflow of 256 bits in intermediate values between the multiplication and division steps.</p>"},{"location":"smart-contracts/libraries/FullMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/FullMath/#safemuldiv","title":"safeMulDiv","text":"<pre><code>  function safeMulDiv(\nuint256 value,\nuint256 multiplier,\nuint256 denominator\n) internal pure returns (uint256 result)\n</code></pre> <p>Calculates floor(value\u00d7multiplier\u00f7denominator) with maximum precision. Reverts if <code>result</code> overflows a uint256 or <code>denominator</code> == 0.</p> <p>Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.</p>"},{"location":"smart-contracts/libraries/FullMath/#parameters","title":"Parameters:","text":"Name Type Description <code>value</code> uint256 The multiplicand <code>multiplier</code> uint256 The multiplier <code>denominator</code> uint256 The divisor"},{"location":"smart-contracts/libraries/FullMath/#return-values","title":"Return Values:","text":"Name Type Description <code>result</code> uint256 The 256-bit result"},{"location":"smart-contracts/libraries/FullMath/#safemuldivceiling","title":"safeMulDivCeiling","text":"<pre><code>  function safeMulDivCeiling(\nuint256 initial,\nuint256 b,\nuint256 denominator\n) internal pure returns (uint256 result)\n</code></pre> <p>Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</p>"},{"location":"smart-contracts/libraries/FullMath/#parameters_1","title":"Parameters:","text":"Name Type Description <code>value</code> uint256 The multiplicand <code>multiplier</code> uint256 The multiplier <code>denominator</code> uint256 The divisor"},{"location":"smart-contracts/libraries/FullMath/#return-values_1","title":"Return Values:","text":"Name Type Description <code>result</code> uint256 The 256-bit result"},{"location":"smart-contracts/libraries/LiquidityMath/","title":"LiquidityMath","text":"<p>Handles modifications to the current liquidity available at a given <code>Tick</code>.</p>"},{"location":"smart-contracts/libraries/LiquidityMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/LiquidityMath/#adddelta","title":"addDelta","text":"<pre><code>  function addDelta(\nuint128 x,\nint128 y\n) internal pure returns (uint128 z)\n</code></pre> <p>Add a signed liquidity delta to liquidity. The function will revert if it overflows or underflows.</p>"},{"location":"smart-contracts/libraries/LiquidityMath/#parameters","title":"Parameters:","text":"Name Type Description <code>x</code> uint128 The liquidity before change <code>y</code> int128 The delta by which liquidity should be changed"},{"location":"smart-contracts/libraries/LiquidityMath/#return-values","title":"Return Values:","text":"Name Type Description <code>z</code> uint128 The modified liquidity amount"},{"location":"smart-contracts/libraries/Position/","title":"Position","text":"<p>Position NFTs represent the owner's liquidity between a lower and upper tick boundary.</p> <p>Positions store additional state for tracking fees owed to the position.</p>"},{"location":"smart-contracts/libraries/Position/#structs","title":"Structs","text":""},{"location":"smart-contracts/libraries/Position/#info","title":"Info","text":"<pre><code>  struct Info {\nuint128 liquidity;\nuint256 feeGrowthInside0LastX128;\nuint256 feeGrowthInside1LastX128;\nuint128 tokensOwed0;\nuint128 tokensOwed1;\n}\n</code></pre>"},{"location":"smart-contracts/libraries/Position/#members","title":"Members:","text":"Name Type Description <code>liquidity</code> uint128 the amount of liquidity owned by this position <code>feeGrowthInside0LastX128</code> uint256 The fee growth inside the tick range for token0 as of the last update to this position <code>feeGrowthInside1LastX128</code> uint256 The fee growth inside the tick range for token1 as of the last update to this position <code>tokensOwed0</code> uint128 the fees owed to the position owner in token0 <code>tokensOwed1</code> uint128 the fees owed to the position owner in token1"},{"location":"smart-contracts/libraries/Position/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/Position/#get","title":"get","text":"<pre><code>  function get(\nmapping(bytes32 =&gt; struct Position.Info) self,\naddress owner,\nint24 tickLower,\nint24 tickUpper\n) internal view returns (struct Position.Info position)\n</code></pre> <p>Returns the Info struct of a <code>Position</code>, given the owner and tick boundaries.</p>"},{"location":"smart-contracts/libraries/Position/#parameters","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(bytes32 =&gt; struct Position.Info) The mapping containing all user positions <code>owner</code> address The address of the position owner <code>tickLower</code> int24 The lower tick boundary of the position <code>tickUpper</code> int24 The upper tick boundary of the position"},{"location":"smart-contracts/libraries/Position/#return-values","title":"Return Values:","text":"Name Type Description <code>position</code> struct Position.Info The position info struct of the given owners' position"},{"location":"smart-contracts/libraries/Position/#update","title":"update","text":"<pre><code>  function update(\nstruct Position.Info self,\nint128 liquidityDelta,\nuint256 feeGrowthInside0X128,\nuint256 feeGrowthInside1X128\n) internal\n</code></pre> <p>Credits accumulated fees to a user's position</p>"},{"location":"smart-contracts/libraries/Position/#parameters_1","title":"Parameters:","text":"Name Type Description <code>self</code> struct Position.Info The mapping containing all user positions <code>liquidityDelta</code> int128 The change in pool liquidity as a result of the position update <code>feeGrowthInside0X128</code> uint256 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries <code>feeGrowthInside1X128</code> uint256 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries"},{"location":"smart-contracts/libraries/Samples/","title":"Samples","text":"<p>The <code>Oracle</code> library provides average tick (i.e. price) and liquidity data that can be utilized for on-chain and off-chain consumption. An array of oracle data titled <code>observations</code> is kept in contract storage and is publicly available for read.</p> <p>Each entry in the oracle array contains averages across a single block of transactions. Each contract starts with an oracle array length of 1. Anyone can increase the number of historical observations.</p> <p>When all indices in the oracle array are full, the index will reset to <code>0</code>. The most recent observation is available by passing in <code>0</code> to <code>observe()</code>.</p>"},{"location":"smart-contracts/libraries/Samples/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/Samples/#initialize","title":"initialize","text":"<pre><code>  function initialize(\nstruct Oracle.Observation[65535] self,\nuint32 time\n) internal returns (uint16 length, uint16 lengthNext)\n</code></pre> <p>Writes the first index of the oracle array. Callable only once.</p>"},{"location":"smart-contracts/libraries/Samples/#parameters","title":"Parameters:","text":"Name Type Description <code>self</code> struct Oracle.Observation[65535] The stored oracle array <code>time</code> uint32 The time of the initialization, i.e. block.timestamp cast as a uint32"},{"location":"smart-contracts/libraries/Samples/#return-values","title":"Return Values:","text":"Name Type Description <code>length</code> uint16 The number of elements which have oracle data <code>lengthNext</code> uint16 The new length of the oracle array"},{"location":"smart-contracts/libraries/Samples/#write","title":"write","text":"<pre><code>  function write(\nstruct Oracle.Observation[65535] self,\nuint16 index,\nuint32 blockTimestamp,\nint24 tick,\nuint128 liquidity,\nuint16 length,\nuint16 lengthNext\n) internal returns (uint16 indexUpdated, uint16 lengthUpdated)\n</code></pre> <p>Writes an <code>Observation</code> to the <code>observations</code> array.</p> <p>Can be called at most once per block. <code>index</code> represents the most recently written element. <code>length</code> and <code>index</code> must be tracked externally.</p> <p>The oracle array length will only be increased when <code>index</code> is at the end of the allowable array length and <code>lengthNext</code> is greater than <code>index</code>. This preserves ordering.</p>"},{"location":"smart-contracts/libraries/Samples/#parameters_1","title":"Parameters:","text":"Name Type Description <code>self</code> struct Oracle.Observation[65535] The stored oracle array <code>index</code> uint16 The location of the most recently updated observation <code>blockTimestamp</code> uint32 The timestamp of the new observation <code>tick</code> int24 The active tick at the time of the new observation <code>liquidity</code> uint128 The total in-range liquidity at the time of the new observation <code>length</code> uint16 The number of populated elements in the oracle array <code>lengthNext</code> uint16 The new length of the oracle array, independent of population"},{"location":"smart-contracts/libraries/Samples/#return-values_1","title":"Return Values:","text":"Name Type Description <code>indexUpdated</code> uint16 The index of the most recently written entry in the oracle array <code>lengthUpdated</code> uint16 The new length of the oracle array"},{"location":"smart-contracts/libraries/Samples/#grow","title":"grow","text":"<pre><code>  function grow(\nstruct Oracle.Observation[65535] self,\nuint16 current,\nuint16 next\n) internal returns (uint16)\n</code></pre> <p>Prepares the oracle array to store up to <code>next</code> observations.</p>"},{"location":"smart-contracts/libraries/Samples/#parameters_2","title":"Parameters:","text":"Name Type Description <code>self</code> struct Oracle.Observation[65535] The stored oracle array <code>current</code> uint16 The current next length of the oracle array <code>next</code> uint16 The proposed next length which will be populated in the oracle array"},{"location":"smart-contracts/libraries/Samples/#return-values_2","title":"Return Values:","text":"Name Type Description <code>next</code> uint16 The next length which will be populated in the oracle array"},{"location":"smart-contracts/libraries/Samples/#observe","title":"observe","text":"<pre><code>  function observe(\nstruct Oracle.Observation[65535] self,\nuint32 time,\nuint32[] secondsAgos,\nint24 tick,\nuint16 index,\nuint128 liquidity,\nuint16 length\n) internal view returns (int56[] tickCumulatives, uint160[] liquidityCumulatives)\n</code></pre> <p>Returns the cumulative tick and liquidity values as of each time in the array <code>secondsAgos</code>.</p> <p>Reverts if <code>secondsAgos</code> &gt; oldest observation.</p>"},{"location":"smart-contracts/libraries/Samples/#parameters_3","title":"Parameters:","text":"Name Type Description <code>self</code> struct Oracle.Observation[65535] The stored oracle array <code>time</code> uint32 The current block.timestamp <code>secondsAgos</code> uint32[] Each amount of time to look back, in seconds, at which point to return an observation <code>tick</code> int24 The current tick <code>index</code> uint16 The location of a given observation within the oracle array <code>liquidity</code> uint128 The current in-range pool liquidity <code>length</code> uint16 The number of populated elements in the oracle array"},{"location":"smart-contracts/libraries/Samples/#return-values_3","title":"Return Values:","text":"Name Type Description <code>tickCumulatives</code> int56[] The tick * time elapsed since the pool was first initialized, as of each <code>secondsAgo</code> <code>liquidityCumulatives</code> uint160[] The liquidity * time elapsed since the pool was first initialized, as of each <code>secondsAgo</code>"},{"location":"smart-contracts/libraries/SqrtPriceMath/","title":"SqrtPriceMath","text":"<p>Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/SqrtPriceMath/#getnextsqrtpricefromamount0roundingup","title":"getNextSqrtPriceFromAmount0RoundingUp","text":"<pre><code>  function getNextSqrtPriceFromAmount0Ceiling(\nuint160 sqrtPX96,\nuint128 liquidity,\nuint256 amount,\nbool add\n) internal pure returns (uint160)\n</code></pre> <p>Gets the next sqrt price given a delta of token0.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters","title":"Parameters:","text":"Name Type Description <code>sqrtPX96</code> uint160 The starting price, i.e. before accounting for the token0 delta <code>liquidity</code> uint128 The amount of usable liquidity <code>amount</code> uint256 How much of token0 to add or remove from virtual reserves <code>add</code> bool Whether to add or remove the amount of token0"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values","title":"Return Values:","text":"Type Description uint160 price after adding or removing amount, depending on add"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getnextsqrtpricefromamount1floor","title":"getNextSqrtPriceFromAmount1Floor","text":"<pre><code>  function getNextSqrtPriceFromAmount1RoundingDown(\nuint160 sqrtPX96,\nuint128 liquidity,\nuint256 amount,\nbool add\n) internal pure returns (uint160)\n</code></pre> <p>Gets the next sqrt price given a delta of token1</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_1","title":"Parameters:","text":"Name Type Description <code>sqrtPX96</code> uint160 The starting price, i.e., before accounting for the token1 delta <code>liquidity</code> uint128 The amount of usable liquidity <code>amount</code> uint256 How much of token1 to add, or remove, from virtual reserves <code>add</code> bool Whether to add, or remove, the amount of token1"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_1","title":"Return Values:","text":"Type Description uint160 price after adding or removing <code>amount</code>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getnextsqrtpricefrominput","title":"getNextSqrtPriceFromInput","text":"<pre><code>  function getNextSqrtPriceFromInput(\nuint160 sqrtPX96,\nuint128 liquidity,\nuint256 amountIn,\nbool zeroForOne\n) internal pure returns (uint160 sqrtQX96)\n</code></pre> <p>Gets the next sqrt price given an input amount of token0 or token1.</p> <p>Reverts if price or liquidity are 0, or if the next price is out of bounds.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_2","title":"Parameters:","text":"Name Type Description <code>sqrtPX96</code> uint160 The starting price, i.e., before accounting for the input amount <code>liquidity</code> uint128 The amount of usable liquidity <code>amountIn</code> uint256 How much of token0, or token1, is being swapped in <code>zeroForOne</code> bool Whether the amount in is token0 or token1"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_2","title":"Return Values:","text":"Name Type Description <code>sqrtQX96</code> uint160 The price after adding the input amount to token0 or token1"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getnextsqrtpricefromoutput","title":"getNextSqrtPriceFromOutput","text":"<pre><code>  function getNextSqrtPriceFromOutput(\nuint160 sqrtPX96,\nuint128 liquidity,\nuint256 amountOut,\nbool zeroForOne\n) internal pure returns (uint160 sqrtQX96)\n</code></pre> <p>Gets the next sqrt price given an output amount of token0 or token1.</p> <p>Reverts if price or liquidity are 0 or the next price is out of bounds.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_3","title":"Parameters:","text":"Name Type Description <code>sqrtPX96</code> uint160 The starting price before accounting for the output amount <code>liquidity</code> uint128 The amount of usable liquidity <code>amountOut</code> uint256 How much of token0, or token1, is being swapped out <code>zeroForOne</code> bool Whether the amount out is token0 or token1"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_3","title":"Return Values:","text":"Name Type Description <code>sqrtQX96</code> uint160 The price after removing the output amount of token0 or token1"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getamount0delta","title":"getAmount0Delta","text":"<pre><code>  function getAmount0Delta(\nuint160 sqrtRatioAX96,\nuint160 sqrtRatioBX96,\nuint128 liquidity,\nbool roundUp\n) internal pure returns (uint256 amount0)\n</code></pre> <p>Gets the amount0 delta between two prices.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_4","title":"Parameters:","text":"Name Type Description <code>sqrtRatioAX96</code> uint160 A sqrt price <code>sqrtRatioBX96</code> uint160 Another sqrt price <code>liquidity</code> uint128 The amount of usable liquidity <code>roundUp</code> bool Whether to round the amount up or down"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_4","title":"Return Values:","text":"Name Type Description <code>amount0</code> uint256 Amount of token0 required to cover a position of size liquidity between the two passed prices"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getamount1delta","title":"getAmount1Delta","text":"<pre><code>  function getAmount1Delta(\nuint160 sqrtRatioAX96,\nuint160 sqrtRatioBX96,\nuint128 liquidity,\nbool roundUp\n) internal pure returns (uint256 amount1)\n</code></pre> <p>Gets the amount1 delta between two prices</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_5","title":"Parameters:","text":"Name Type Description <code>sqrtRatioAX96</code> uint160 A sqrt price <code>sqrtRatioBX96</code> uint160 Another sqrt price <code>liquidity</code> uint128 The amount of usable liquidity <code>roundUp</code> bool Whether to round the amount up, or down"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_5","title":"Return Values:","text":"Name Type Description <code>amount1</code> uint256 Amount of token1 required to cover a position of size liquidity between the two passed prices"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getamount0delta_1","title":"getAmount0Delta","text":"<pre><code>  function getAmount0Delta(\nuint160 sqrtRatioAX96,\nuint160 sqrtRatioBX96,\nint128 liquidity\n) internal pure returns (int256 amount0)\n</code></pre> <p>Get delta for token0 given two sqrt prices.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_6","title":"Parameters:","text":"Name Type Description <code>sqrtRatioAX96</code> uint160 A sqrt price <code>sqrtRatioBX96</code> uint160 Another sqrt price <code>liquidity</code> int128 The change in liquidity for which to compute the amount0 delta"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_6","title":"Return Values:","text":"Name Type Description <code>amount0</code> int256 Amount of token0 corresponding to the passed liquidityDelta between the two prices"},{"location":"smart-contracts/libraries/SqrtPriceMath/#getamount1delta_1","title":"getAmount1Delta","text":"<pre><code>  function getAmount1Delta(\nuint160 sqrtRatioAX96,\nuint160 sqrtRatioBX96,\nint128 liquidity\n) internal pure returns (int256 amount1)\n</code></pre> <p>Get delta for token0 given two sqrt prices.</p>"},{"location":"smart-contracts/libraries/SqrtPriceMath/#parameters_7","title":"Parameters:","text":"Name Type Description <code>sqrtRatioAX96</code> uint160 A sqrt price <code>sqrtRatioBX96</code> uint160 Another sqrt price <code>liquidity</code> int128 The change in liquidity for which to compute the amount1 delta"},{"location":"smart-contracts/libraries/SqrtPriceMath/#return-values_7","title":"Return Values:","text":"Name Type Description <code>amount1</code> int256 Amount of token1 corresponding to the passed liquidityDelta between the two prices"},{"location":"smart-contracts/libraries/SwapMath/","title":"SwapMath","text":"<p>Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.</p>"},{"location":"smart-contracts/libraries/SwapMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/SwapMath/#computeswapstep","title":"computeSwapStep","text":"<pre><code>  function computeSwapStep(\nuint160 sqrtRatioCurrentX96,\nuint160 sqrtRatioTargetX96,\nuint128 liquidity,\nint256 amountRemaining,\nuint24 feePips\n) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount)\n</code></pre> <p>Computes the result of swapping some amount in, or amount out, given the parameters of the swap.</p> <p>The <code>feeAmount</code> plus the <code>amountIn</code> can never exceed <code>amountRemaining</code>.</p>"},{"location":"smart-contracts/libraries/SwapMath/#parameters","title":"Parameters:","text":"Name Type Description <code>sqrtRatioCurrentX96</code> uint160 The current sqrt price of the pool <code>sqrtRatioTargetX96</code> uint160 The price that cannot be exceeded, from which the direction of the swap is inferred <code>liquidity</code> uint128 The usable liquidity <code>amountRemaining</code> int256 How much input or output amount is remaining to be swapped in/out <code>feePips</code> uint24 The fee taken from the input amount, expressed in hundredths of a bip"},{"location":"smart-contracts/libraries/SwapMath/#return-values","title":"Return Values:","text":"Name Type Description <code>sqrtRatioNextX96</code> uint160 The price after swapping the amount in/out, not to exceed the price target <code>amountIn</code> uint256 The amount to be swapped in, of either token0 or token1, based on the direction of the swap <code>amountOut</code> uint256 The amount to be received, of either token0 or token1, based on the direction of the swap <code>feeAmount</code> uint256 The amount of input that will be taken as a fee"},{"location":"smart-contracts/libraries/Tick/","title":"Tick","text":"<p>Handles management of individual tick data and calculations.</p>"},{"location":"smart-contracts/libraries/Tick/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/Tick/#tickspacingtomaxliquiditypertick","title":"tickSpacingToMaxLiquidityPerTick","text":"<pre><code>  function tickSpacingToMaxLiquidityPerTick(\nint24 tickSpacing\n) internal pure returns (uint128)\n</code></pre> <p>Derives max liquidity per tick from given tick spacing</p> <p>Executed within the pool constructor</p>"},{"location":"smart-contracts/libraries/Tick/#parameters","title":"Parameters:","text":"Name Type Description <code>tickSpacing</code> int24 The amount of required tick separation, realized in multiples of <code>tickSpacing</code> e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ..."},{"location":"smart-contracts/libraries/Tick/#return-values","title":"Return Values:","text":"Type Description uint128 max liquidity per tick"},{"location":"smart-contracts/libraries/Tick/#getfeegrowthinside","title":"getFeeGrowthInside","text":"<pre><code>  function getFeeGrowthInside(\nmapping(int24 =&gt; struct Tick.Info) self,\nint24 tickLower,\nint24 tickUpper,\nint24 tickCurrent,\nuint256 feeGrowthGlobal0X128,\nuint256 feeGrowthGlobal1X128\n) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n</code></pre> <p>Retrieves fee growth data</p>"},{"location":"smart-contracts/libraries/Tick/#parameters_1","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(int24 =&gt; struct Tick.Info) The mapping containing all tick information for initialized ticks <code>tickLower</code> int24 The lower tick boundary of the position <code>tickUpper</code> int24 The upper tick boundary of the position <code>tickCurrent</code> int24 The current tick <code>feeGrowthGlobal0X128</code> uint256 The all-time global fee growth, per unit of liquidity, in token0 <code>feeGrowthGlobal1X128</code> uint256 The all-time global fee growth, per unit of liquidity, in token1"},{"location":"smart-contracts/libraries/Tick/#return-values_1","title":"Return Values:","text":"Name Type Description <code>feeGrowthInside0X128</code> uint256 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries <code>feeGrowthInside1X128</code> uint256 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries"},{"location":"smart-contracts/libraries/Tick/#update","title":"update","text":"<pre><code>  function update(\nmapping(int24 =&gt; struct Tick.Info) self,\nint24 tick,\nint24 tickCurrent,\nint128 liquidityDelta,\nuint256 feeGrowthGlobal0X128,\nuint256 feeGrowthGlobal1X128,\nbool upper,\nuint128 maxLiquidity\n) internal returns (bool flipped)\n</code></pre> <p>Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa</p>"},{"location":"smart-contracts/libraries/Tick/#parameters_2","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(int24 =&gt; struct Tick.Info) The mapping containing all tick information for initialized ticks <code>tick</code> int24 The tick that will be updated <code>tickCurrent</code> int24 The current tick <code>liquidityDelta</code> int128 A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left) <code>feeGrowthGlobal0X128</code> uint256 The all-time global fee growth, per unit of liquidity, in token0 <code>feeGrowthGlobal1X128</code> uint256 The all-time global fee growth, per unit of liquidity, in token1 <code>upper</code> bool true for updating a position's upper tick, or false for updating a position's lower tick <code>maxLiquidity</code> uint128 The maximum liquidity allocation for a single tick"},{"location":"smart-contracts/libraries/Tick/#return-values_2","title":"Return Values:","text":"Name Type Description <code>flipped</code> bool Whether the tick was flipped from initialized to uninitialized, or vice versa"},{"location":"smart-contracts/libraries/Tick/#clear","title":"clear","text":"<pre><code>  function clear(\nmapping(int24 =&gt; struct Tick.Info) self,\nint24 tick\n) internal\n</code></pre> <p>Clears tick data</p>"},{"location":"smart-contracts/libraries/Tick/#parameters_3","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(int24 =&gt; struct Tick.Info) The mapping containing all initialized tick information for initialized ticks <code>tick</code> int24 The tick that will be cleared"},{"location":"smart-contracts/libraries/Tick/#cross","title":"cross","text":"<pre><code>  function cross(\nmapping(int24 =&gt; struct Tick.Info) self,\nint24 tick,\nuint256 feeGrowthGlobal0X128,\nuint256 feeGrowthGlobal1X128\n) internal returns (int128 liquidityNet)\n</code></pre> <p>Transitions to next tick as needed by price movement</p>"},{"location":"smart-contracts/libraries/Tick/#parameters_4","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(int24 =&gt; struct Tick.Info) The mapping containing all tick information for initialized ticks <code>tick</code> int24 The destination tick of the transition <code>feeGrowthGlobal0X128</code> uint256 The all-time global fee growth, per unit of liquidity, in token0 <code>feeGrowthGlobal1X128</code> uint256 The all-time global fee growth, per unit of liquidity, in token1"},{"location":"smart-contracts/libraries/Tick/#return-values_3","title":"Return Values:","text":"Name Type Description <code>liquidityNet</code> int128 The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)"},{"location":"smart-contracts/libraries/TickBitmap/","title":"TickBitmap","text":"<p>Stores a packed mapping of tick index to its initialized state</p> <p>The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.</p>"},{"location":"smart-contracts/libraries/TickBitmap/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/TickBitmap/#fliptick","title":"flipTick","text":"<pre><code>  function flipTick(\nmapping(int16 =&gt; uint256) self,\nint24 tick,\nint24 tickSpacing\n) internal\n</code></pre> <p>Flips the initialized state for a given tick from false to true, or vice versa</p>"},{"location":"smart-contracts/libraries/TickBitmap/#parameters","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(int16 =&gt; uint256) The mapping in which to flip the tick <code>tick</code> int24 The tick to flip <code>tickSpacing</code> int24 The spacing between usable ticks"},{"location":"smart-contracts/libraries/TickBitmap/#nextinitializedtickwithinoneword","title":"nextInitializedTickWithinOneWord","text":"<pre><code>  function nextInitializedTickWithinOneWord(\nmapping(int16 =&gt; uint256) self,\nint24 tick,\nint24 tickSpacing,\nbool lte\n) internal view returns (int24 next, bool initialized)\n</code></pre> <p>Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either to the left (less than or equal to) or right (greater than) of the given tick</p>"},{"location":"smart-contracts/libraries/TickBitmap/#parameters_1","title":"Parameters:","text":"Name Type Description <code>self</code> mapping(int16 =&gt; uint256) The mapping in which to compute the next initialized tick <code>tick</code> int24 The starting tick <code>tickSpacing</code> int24 The spacing between usable ticks <code>lte</code> bool Whether to search for the next initialized tick to the left (less than or equal to the starting tick)"},{"location":"smart-contracts/libraries/TickBitmap/#return-values","title":"Return Values:","text":"Name Type Description <code>next</code> int24 The next initialized or uninitialized tick up to 256 ticks away from the current tick <code>initialized</code> bool Whether the next tick is initialized, as the function only searches within up to 256 ticks"},{"location":"smart-contracts/libraries/TickMath/","title":"TickMath","text":"<p>Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2-128 and 2128</p>"},{"location":"smart-contracts/libraries/TickMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/TickMath/#getsqrtratioattick","title":"getSqrtRatioAtTick","text":"<pre><code>  function getSqrtRatioAtTick(\nint24 tick\n) internal pure returns (uint160 sqrtPriceX96)\n</code></pre> <p>Calculates sqrt(1.0001^tick) * 2^96</p> <p>Throws if |tick| &gt; max tick</p>"},{"location":"smart-contracts/libraries/TickMath/#parameters","title":"Parameters:","text":"Name Type Description <code>tick</code> int24 The input tick for the above formula"},{"location":"smart-contracts/libraries/TickMath/#return-values","title":"Return Values:","text":"Name Type Description <code>sqrtPriceX96</code> uint160 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) <p>at the given tick</p>"},{"location":"smart-contracts/libraries/TickMath/#gettickatsqrtratio","title":"getTickAtSqrtRatio","text":"<pre><code>  function getTickAtSqrtRatio(\nuint160 sqrtPriceX96\n) internal pure returns (int24 tick)\n</code></pre> <p>Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio</p> <p>Throws in case sqrtPriceX96 &lt; MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may ever return.</p>"},{"location":"smart-contracts/libraries/TickMath/#parameters_1","title":"Parameters:","text":"Name Type Description <code>sqrtPriceX96</code> uint160 The sqrt ratio for which to compute the tick as a Q64.96"},{"location":"smart-contracts/libraries/TickMath/#return-values_1","title":"Return Values:","text":"Name Type Description <code>tick</code> int24 The greatest tick for which the ratio is less than or equal to the input ratio"},{"location":"smart-contracts/libraries/UnsafeMath/","title":"UnsafeMath","text":"<p>Contains methods that perform common math functions but do not do any overflow or underflow checks</p>"},{"location":"smart-contracts/libraries/UnsafeMath/#functions","title":"Functions","text":""},{"location":"smart-contracts/libraries/UnsafeMath/#divroundingup","title":"divRoundingUp","text":"<pre><code>  function divRoundingUp(\nuint256 x,\nuint256 y\n) internal pure returns (uint256 z)\n</code></pre> <p>Returns ceil(x / y)</p> <p>panics if y == 0</p>"},{"location":"smart-contracts/libraries/UnsafeMath/#parameters","title":"Parameters:","text":"Name Type Description <code>x</code> uint256 The dividend <code>y</code> uint256 The divisor"},{"location":"smart-contracts/libraries/UnsafeMath/#return-values","title":"Return Values:","text":"Name Type Description <code>z</code> uint256 The quotient, ceil(x / y)"},{"location":"smart-contracts/limit/LimitPool/","title":"LimitPool","text":"<p>Manages limit liquidity positions.</p>"},{"location":"smart-contracts/limit/LimitPool/#functions","title":"Functions","text":""},{"location":"smart-contracts/limit/LimitPool/#mint","title":"mint","text":"<p><pre><code>    function mint(\nMintParams memory params\n    ) external lock\n\nstruct MintParams {\naddress to;\nuint128 amount;\nint24 lower;\nint24 claim;\nint24 upper;\nbool zeroForOne;\n}\n</code></pre> Mints a Limit LP for the range <code>lower</code> to <code>upper</code>.</p> <p><code>lower</code> will be the lower price tick for the position.</p> <p><code>upper</code> will be the upper tick for the position.</p> <p>Both <code>lower</code> and <code>upper</code> must be multiples of the <code>tickSpread</code> for the pool.</p> <p><code>claim</code> only need be an exact value in the case the user has already minted a position with the same <code>lower</code> and <code>upper</code>.</p> <p>If this is the case, the <code>claim</code> tick must be the furthest tick crossed into the position.</p> <p><code>zeroForOne</code> as <code>true</code> means the LP deposits <code>token0</code> and is filled with <code>token1</code>. <code>zeroForOne</code> as <code>false</code> means the LP deposits <code>token1</code> and is filled with <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>to</code> int24 The recipient of the fungible position <code>lower</code> int24 The lower price tick of the range <code>claim</code> int24 The claim price tick of the range <code>upper</code> int24 The upper price tick of the range <code>amount</code> uint128 The amount of the input token to add to the <code>Position</code> <code>zeroForOne</code> bool <code>true</code> for <code>token0</code> =&gt; <code>token1</code> and <code>false</code> for <code>token1</code> =&gt; <code>token0</code> <p> Return Values: </p> Name Type Description <code>amount</code> uint256 The amount of the input token that was added to mint liquidity."},{"location":"smart-contracts/limit/LimitPool/#burn","title":"burn","text":"<pre><code>    function burn(\nBurnParams memory params\n    ) external lock\n\nstruct BurnParams {\naddress to;\nuint128 burnPercent;\nint24 lower;\nint24 claim;\nint24 upper;\nbool zeroForOne;\nbool sync;\n}\n</code></pre> <p>Burns liquidity from <code>msg.sender</code>. The token received from the burned liquidity is then sent to the address <code>to</code>.</p> <p><code>burnPercent</code> is a number no greater than <code>1e38</code> which equals 100%.</p> <p><code>lower</code> and <code>upper</code> must match a position owned by the caller.</p> <p><code>zeroForOne</code> will be <code>true</code> if the LP is trading <code>token1</code> for <code>token0</code> and <code>false</code> if the LP is trading <code>token1</code> for <code>token0</code>.</p> <p><code>sync</code> should be <code>true</code> in most cases to receive the <code>syncFee</code> if available. <code>false</code> should only be used if the user wants to exit their LP without syncing the pool.</p> <p> Parameters: </p> Name Type Description <code>to</code> int24 The recipient of the token from the burned liquidity <code>burnPercent</code> uint128 The percent of the user's liquidity to be burned and collected (1e38 = 100%) <code>lower</code> int24 The lower price tick of the range <code>claim</code> int24 The claim price tick of the range <code>upper</code> int24 The upper price tick of the range <code>zeroForOne</code> bool <code>true</code> for <code>token0</code> =&gt; <code>token1</code> and <code>false</code> for <code>token1</code> =&gt; <code>token0</code> <code>zeroForOne</code> bool <code>true</code> to allow sync and <code>false</code> to skip sync <p> Return Values: </p> Name Type Description <code>amount0</code> uint256 The amount of token0 collected for burning liquidity. Matches the value in the callback <code>amount1</code> uint256 The amount of token1 collected for burning liquidity. Matches the value in the callback"},{"location":"smart-contracts/limit/LimitPool/#swap","title":"swap","text":"<pre><code>    function swap(\naddress recipient,\nbool zeroForOne,\nuint256 amountIn,\nuint160 priceLimit\n) external override lock\n</code></pre> <p>Swaps <code>token0</code> for <code>token1</code> or <code>token1</code> for <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>recipient</code> address The address to receive the output of the swap <code>zeroForOne</code> bool The direction of the swap, true for <code>token0</code> =&gt; <code>token1</code>, false for <code>token1</code> =&gt; <code>token0</code> <code>amountIn</code> int256 The token amount for the swap <code>priceLimit</code> uint160 The Q64.96 sqrt price limit. If <code>zeroForOne</code> is true, the price cannot be less than this value after the swap. If <code>zeroForOne</code> is false, the price cannot be greater than this value after the swap. <code>data</code> bytes Raw data being passed through to the callback"},{"location":"smart-contracts/limit/LimitPool/#quote","title":"quote","text":"<pre><code>    function quote(\naddress recipient,\nbool zeroForOne,\nuint256 amountIn,\nuint160 priceLimit\n) external override lock\n</code></pre> <p>Swap <code>token0</code> for <code>token1</code>, or <code>token1</code> for <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>recipient</code> address The address to receive the output of the swap <code>zeroForOne</code> bool The direction of the swap, true for <code>token0</code> =&gt; <code>token1</code>, false for <code>token1</code> =&gt; <code>token0</code> <code>amountIn</code> int256 The token amount for the swap <code>priceLimit</code> uint160 The Q64.96 sqrt price limit. If <code>zeroForOne</code> is true, the price cannot be less than this value after the swap. If <code>zeroForOne</code> is false, the price cannot be greater than this value after the swap. <code>data</code> bytes Raw data being passed through to the callback <p> Return Values: </p> Name Type Description <code>amount0</code> uint128 The change in the pool <code>token0</code> balance <code>amount1</code> uint128 The change in the pool <code>token1</code> balance"},{"location":"smart-contracts/limit/LimitPool/#collectprotocolfees","title":"collectProtocolFees","text":"<pre><code>    function protocolFees(\nuint16 fillFee,\nbool setFees\n) external ownerOnly returns (\nuint128 token0Fees,\nuint128 token1Fees\n)\n</code></pre> <p>Collect the protocol fees accrued by the pool.</p> <p> Parameters: </p> Name Type Description <code>fillFee</code> uint16 The feet set based on fill amount <code>setFees</code> bool Whether the fee should be set in this call or not <p> Return Values: </p> Name Type Description <code>token0Fees</code> uint128 The protocol fee collected in token0 <code>token1Fees</code> uint128 The protocol fee collected in token1 <p> </p>"},{"location":"smart-contracts/limit/LimitPoolFactory/","title":"LimitPoolFactory","text":"<p>Creates and gets price pools. </p>"},{"location":"smart-contracts/limit/LimitPoolFactory/#functions","title":"Functions","text":""},{"location":"smart-contracts/limit/LimitPoolFactory/#createlimitpool","title":"createLimitPool","text":"<p><pre><code>    function createLimitPool(\naddress tokenIn,\naddress tokenOut\n) external override returns (address pool)\n</code></pre> Creates a Limit Pool for the given two ERC-20 tokens.</p> <p>The addresses of <code>tokenIn</code> and <code>tokenOut</code> will have their addresses sorted lexicographically (i.e. first by number then by letter) to represent <code>token0</code> and <code>token1</code>.</p> <p>The contract call will revert with <code>PoolAlreadyExists()</code> if the pool already exists.</p> <p> Parameters: </p> Name Type Description <code>tokenIn</code> address The first ERC-20 token by ordering in the pool <code>tokenOut</code> address The second ERC-20 token by ordering in the pool <p> Return Values: </p> Name Type Description <code>pool</code> address The generated address for the pool"},{"location":"smart-contracts/limit/LimitPoolFactory/#getlimitpool","title":"getLimitPool","text":"<pre><code>    function getLimitPool(\naddress tokenIn,\naddress tokenOut\n) external view override returns (address)\n</code></pre> <p>Gets the pool for the given two ERC-20 tokens with the selected fee tier.</p> <p>If such a pool does not exist, <code>address(0)</code> will be returned.</p> <p> Parameters: </p> Name Type Description <code>tokenIn</code> address The first ERC-20 token by ordering in the pool <code>tokenOut</code> address The second ERC-20 token by ordering in the pool <p> Return Values: </p> Name Type Description <code>pool</code> address The address of the found pool (if exists) <p> </p>"},{"location":"smart-contracts/range/RangePool/","title":"RangePool","text":"<p>Manages range liquidity positions.</p>"},{"location":"smart-contracts/range/RangePool/#functions","title":"Functions","text":""},{"location":"smart-contracts/range/RangePool/#mint","title":"mint","text":"<p><pre><code>  function mint(\nMintParams memory params\n  ) external lock\n\nstruct MintParams {\naddress to;\nint24 lower;\nint24 upper;\nuint128 amount0;\nuint128 amount1;\nbool fungible;\n}\n</code></pre> Mints an ERC-1155 for the range <code>lower</code> to <code>upper</code>.</p> <p><code>lower</code> will be the lower price tick for the position.</p> <p><code>upper</code> will be the upper tick for the position.</p> <p>Both <code>lower</code> and <code>upper</code> must be multiples of the <code>tickSpacing</code> for the pool.</p> <p>If a <code>Position</code> is out of range, it will not collect fees.</p> <p>Fees for the matching ERC-1155 id will be autocompounded when calling this function.</p> <p> Parameters: </p> Name Type Description <code>to</code> int24 The recipient of the fungible position <code>lower</code> int24 The lower price tick of the range <code>upper</code> int24 The upper price tick of the range <code>amount0</code> uint128 The amount of <code>token0</code> to add to the <code>Position</code> <code>amount1</code> uint128 The amount of <code>token1</code> to add to the <code>Position</code> <p> Return Values: </p> Name Type Description <code>amount0</code> uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback <code>amount1</code> uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},{"location":"smart-contracts/range/RangePool/#burn","title":"burn","text":"<pre><code>  function burn(\nBurnParams memory params\n  ) external lock\n\nstruct BurnParams {\naddress to;\nint24 lower;\nint24 upper;\nuint128 amount;\nbool fungible;\nbool collect;\n}\n</code></pre> <p>Burn liquidity from <code>msg.sender</code>. The token received from the burned liquidity is then sent to the address <code>to</code>.</p> <p> Parameters: </p> Name Type Description <code>to</code> int24 The recipient of the token from the burned liquidity <code>lower</code> int24 The lower price tick of the range <code>upper</code> int24 The upper price tick of the range <code>burnPercent</code> uint128 The percent of the user's liquidity to be burned and collected (1e38 = 100%) <p> Return Values: </p> Name Type Description <code>amount0</code> uint256 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback <code>amount1</code> uint256 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},{"location":"smart-contracts/range/RangePool/#swap","title":"swap","text":"<pre><code>  function swap(\naddress recipient,\nbool zeroForOne,\nuint256 amountIn,\nuint160 priceLimit\n) external override lock\n</code></pre> <p>Swap <code>token0</code> for <code>token1</code>, or <code>token1</code> for <code>token0</code>.</p> <p> Parameters: </p> Name Type Description <code>recipient</code> address The address to receive the output of the swap <code>zeroForOne</code> bool The direction of the swap, true for <code>token0</code> =&gt; <code>token1</code>, false for <code>token1</code> =&gt; <code>token0</code> <code>amountSpecified</code> int256 The amount of the swap, which if positive is exact input, or if negative is exact output <code>priceLimit</code> uint160 The Q64.96 sqrt price limit. If <code>zeroForOne</code> is true, the price cannot be less than this value after the swap. If <code>zeroForOne</code> is false, the price cannot be greater than this value after the swap. <code>data</code> bytes Raw data being passed through to the callback <p> Return Values: </p> Name Type Description <code>amount0</code> int256 The delta of the balance of <code>token0</code> of the pool, exact when negative, minimum when positive <code>amount1</code> int256 The delta of the balance of <code>token1</code> of the pool, exact when negative, minimum when positive"},{"location":"smart-contracts/range/RangePool/#increasesamplelength","title":"increaseSampleLength","text":"<pre><code>  function increaseSampleLength(\nuint16 sampleLengthNext\n) external override lock\n</code></pre> <p>Increase the maximum number of price and liquidity samples that can be stored by the pool.</p> <p>This method will not modify state if the pool already has a <code>sampleLengthNext</code> greater than or equal to the input <code>sampleLengthNext</code>.</p> <p> Parameters: </p> Name Type Description <code>observationLengthNext</code> uint16 The desired minimum number of observations for the pool to store"},{"location":"smart-contracts/range/RangePool/#collectprotocolfees","title":"collectProtocolFees","text":"<pre><code>  function collectProtocolFees(\n) external lock returns (\nuint128 token0Fees,\nuint128 token1Fees\n)\n</code></pre> <p>Collect the protocol fees accrued by the pool.</p> <p> Parameters: </p> <p> Return Values: </p> Name Type Description <code>token0Fees</code> uint128 The protocol fee collected in token0 <code>token1Fees</code> uint128 The protocol fee collected in token1 <p> </p>"},{"location":"smart-contracts/range/RangePoolFactory/","title":"RangePoolFactory","text":"<p>Creates and gets range pools. </p>"},{"location":"smart-contracts/range/RangePoolFactory/#functions","title":"Functions","text":""},{"location":"smart-contracts/range/RangePoolFactory/#createrangepool","title":"createRangePool","text":"<pre><code>  function createRangePool(\naddress tokenIn,\naddress tokenOut,\nuint16  swapFee,\nuint160 startPrice\n) external override returns (address pool)\n</code></pre> <p>Creates a pool for the given two ERC-20 tokens with the selected fee tier.</p> <p>The addresses of <code>tokenIn</code> and <code>tokenOut</code> will have their addresses sorted lexicographically (i.e. first by number then by letter) to represent <code>token0</code> and <code>token1</code>.</p> <p><code>tickSpacing</code> is retrieved based on the fee tier selected. </p> <p>The contract call will revert with <code>PoolAlreadyExists()</code> if the pool already exists, <code>FeeTierNotSupported()</code> if the fee tier is not supported, or <code>InvalidTokenAddress</code> if one of the token addresses is invalid.</p> <p> Parameters: </p> Name Type Description <code>tokenIn</code> address The first ERC-20 token by ordering in the pool <code>tokenOut</code> address The second ERC-20 token by ordering in the pool <code>swapFee</code> uint24 The selected fee tier for the pool <code>startPrice</code> uint256 The select maker tier defining the minimum order size <p> Return Values: </p> Name Type Description <code>pool</code> address The generated address for the pool"},{"location":"smart-contracts/range/RangePoolFactory/#getrangepool","title":"getRangePool","text":"<pre><code>  function getRangePool(\naddress tokenIn,\naddress tokenOut,\nuint256 swapFee\n) public view override returns (address)\n</code></pre> <p>Gets the pool for the given two ERC-20 tokens with the selected fee tier.</p> <p>If such a pool does not exist, <code>address(0)</code> will be returned.</p> <p> Parameters: </p> Name Type Description <code>tokenIn</code> address The first ERC-20 token to pair in the pool <code>tokenOut</code> address The second ERC-20 token to pair in the pool <code>swapFee</code> uint24 The selected fee tier for the po <p> Return Values: </p> Name Type Description <code>pool</code> address The address of the found pool (if exists) <p> </p>"},{"location":"tutorials/how-to-cover/","title":"How to LP on Cover","text":""},{"location":"tutorials/how-to-cover/#minting-a-position","title":"Minting a Position","text":"<pre><code>This is the basis for hedging risk. The equivalent of a stop loss.\n</code></pre> <p>A cover position consists of you choosing token A which you want to hedge price risk for (which you currently hold in your wallet) and token B to receive in the event one of the trigger prices for your stop loss are met, this token B is also used as the unit to price token B.</p> <ul> <li> 1. Click \u2018Connect Wallet\u2019.</li> </ul> <p></p> <ul> <li> 2. Connect your wallet through the widget.</li> </ul> <p></p> <ul> <li> 3. Navigate to the \u201cCover\u201d page.</li> </ul> <p></p> <p>If you are looking to cover and existing range pool position please move to Select Pool to Cover otherwise scroll to Create and Independent Cover Position</p>"},{"location":"tutorials/how-to-cover/#select-pool-to-cover","title":"Select Pool to Cover","text":"<ul> <li> 4. Click \u2018 Select a Pool to Cover\u2019.</li> </ul> <ul> <li> 5. Select one of your existing concentrated liquidity positions.</li> </ul> <ul> <li> <p> 6. Choose the amount of your position to cover.</p> </li> <li> <p> 7. Select the volatility tier for your position (See Documentation for more info).</p> </li> <li> <p> 8. Choose the price range you wish to cover your liquidity over.</p> </li> </ul> <p></p> <ul> <li> <p> 9. Finally, click \u201cApprove\u201d and approve the movement of your tokens.</p> </li> <li> <p> 10. You will receive an approval signature request in your wallet. Press \u2018Confirm\u2019 in your wallet to confirm the approval.</p> </li> <li> <p> 11. Wait for the approval transaction to confirm.</p> </li> <li> <p> 12. Click \u2018Create Cover\u2019 to create the position.</p> </li> </ul> <p></p> <ul> <li> <p> 13. You will receive a create cover position signature request in your wallet. Press \u2018Confirm\u2019 in your wallet to confirm the swap.</p> </li> <li> <p> 14. Wait for the transaction to be confirmed and executed in the next block.</p> </li> <li> <p> 15. Congratulations you have just created your Cover position on Poolshark! Click the pop-up to view on Arbiscan.</p> </li> </ul>"},{"location":"tutorials/how-to-cover/#create-an-independent-cover-position","title":"Create an Independent Cover Position","text":"<ul> <li> 4. Select \u201cCreate my own Cover\u201d.</li> </ul> <ul> <li> 5. Select the input token that you currently have in your wallet by clicking on the drop down.</li> </ul> <ul> <li> 6. Search for the input token within the list by typing or scrolling and click on it.</li> </ul> <ul> <li> <p> 7. Repeat steps 5 and 6 for the output token.</p> </li> <li> <p> 8. Choose the amount of your input token to cover.</p> </li> <li> <p> 9. Select the volatility tier for your position (link to volatility tier documentation).</p> </li> <li> <p> 10. Choose the price range you wish to cover your liquidity over.</p> </li> </ul> <p></p> <ul> <li> 11. Finally, click \u201cApprove\u201d to approve the spend of your tokens.</li> </ul> <p></p> <ul> <li> <p> 12. You will receive an approval signature request in your wallet. Press \u2018Confirm\u2019 in your wallet to confirm the approval.</p> </li> <li> <p> 13. Wait for the approval transaction to confirm.</p> </li> <li> <p> 14. Click \u2018Create Cover\u2019 to create the position.</p> </li> <li> <p> 15. You will receive a create cover position signature request in your wallet. Press \u2018Confirm\u2019 in your wallet to confirm the swap.</p> </li> <li> <p> 16. Wait for the transaction to be confirmed and executed in the next block.</p> </li> <li> <p> 17. Congratulations you have just created your Cover position on Poolshark! Click the pop-up to view on Arbiscan.</p> </li> </ul> <p></p>"},{"location":"tutorials/how-to-range/","title":"How to LP on Range","text":""},{"location":"tutorials/how-to-range/#minting-a-position","title":"Minting a Position","text":"<pre><code>This is a typical bidirectional liquidity position ([See Documentation for more info](https://docs.poolshark.fi/overview/glossary/#bidirectional-automated-market-maker))\n</code></pre> <ul> <li> 1. Click \u2018Connect Wallet\u2019.</li> </ul> <ul> <li> 2. Connect your wallet through the widget.</li> </ul> <ul> <li> <p> 3. Navigate to the \u201cPool\u201d page.</p> </li> <li> <p> 4. Select the token pair you want to provide liquidity on.</p> </li> </ul> <p></p> <ul> <li> 5. Alternatively select the <code>token 0</code> for input and output and a pool can be created.</li> </ul> <p></p> <ul> <li> 6. Find it within the token widget by clicking or searching.</li> </ul> <p></p> <ul> <li> 7. Repeat the same process for <code>token 1</code> by clicking selecting the second token.</li> </ul> <p></p> <ul> <li> 8. Select the fee tier (See Documentation for more info) to provide liquidity at.</li> </ul> <p></p> <ul> <li> <p> 9. Input the range you would like to provide liquidity within (this will impact the number of tokens you input as it is based on where the current price is within the range).</p> </li> <li> <p> 10. Enter the number of each token(s) you would like to provide within this range.</p> </li> </ul> <p></p> <ul> <li> 11. Click \"Preview\" to make sure the fields are filled to your liking.</li> </ul> <p></p> <ul> <li> 12. Within the Preview pop-up click the button and it will open up allowances for each token if this is the first time creating a position with these tokens on Poolshark.</li> </ul> <p></p> <ul> <li> <p> 13. Click confirm on the signature requests for the allowances within your wallet.</p> </li> <li> <p> 14. Click \u201cMint Position\u201d and it will send an approval signature request to your connected wallet to create the position.</p> </li> <li> <p> 15. Click confirm on your wallet to sign the approval.</p> </li> <li> <p> 16. Wait for the transaction to confirm in the next block.</p> </li> <li> <p> 17. Congratulations you have just created your first range position on Poolshark! Click the pop-up to view on Arbiscan.</p> </li> </ul> <p></p>"},{"location":"tutorials/how-to-swap/","title":"How to Swap","text":"<pre><code>This is the basis for all trading. The equivalent of a market order.\n</code></pre> <ul> <li> 1. Click \u2018Connect Wallet\u2019.</li> </ul> <ul> <li> 2. Connect your wallet through the widget.</li> </ul> <ul> <li> <p> 3. Navigate to the \u201cSwap\u201d page (It should be selected by default).</p> </li> <li> <p> 4. Select your desired input token by clicking on the drop down arrow.</p> </li> </ul> <p></p> <ul> <li> 5. Find your desired token by clicking on the list or searching for it by name.</li> </ul> <p></p> <ul> <li> 6. Repeat the same process as Step 4 and 5 to select your desired output token.</li> </ul> <p></p> <ul> <li> <p> 7. Enter the amount of the input token you wish to swap.</p> </li> <li> <p> 8. Cick \u201cSwap\u201d to Approve the router to swap your tokens (only applies if this has been your first time swapping this input token on Poolshark).</p> </li> </ul> <p></p> <ul> <li> <p> 9. You will receive an approval signature request in your wallet. Press \u2018Confirm\u2019 in your wallet to confirm the approval.</p> </li> <li> <p> 10. Wait for the approval transaction to confirm.</p> </li> <li> <p> 11. Click \u2018Swap\u2019 to execute the swap.</p> </li> <li> <p> 12. You will receive a swap signature request in your wallet. Press \u2018Confirm\u2019 in your wallet to confirm the swap.</p> </li> <li> <p> 13. Wait for the transaction to be confirmed and executed in the next block.</p> </li> <li> <p> 14. Congratulations you have just finished your first swap on Poolshark! Click the pop-up to view on Arbiscan.</p> </li> </ul> <p></p> <p></p>"},{"location":"whitepaper/","title":"Whitepaper","text":"<p>Click one of the links below to view the whitepaper as a PDF.</p> <p>Release notes</p> <p>Whitepaper Version 1.0.1: February 2023</p> <ul> <li>Cover Pool Overview</li> <li>Limit Pool Overview</li> <li>Cover Pool Pre-Audit Implementation</li> </ul> <p>Whitepaper Version 1.0.0: January 2023</p> <ul> <li>Introduction</li> <li>Motivation</li> <li>High-level overview</li> <li>Cover Pool Initial Implementation</li> </ul>"}]}